## 雪花算法

分布式系统中，有一些需要使用全局唯一 ID 的场景，这种时候为了防止 ID 冲突可以使用 36 位的 UUID，但是 UUID 有一些缺点，首先他相对比较长，另外 UUID 一般是无序的。

有些时候我们希望能使用一种简单些的 ID，并且希望 ID 能够按照时间有序生成。

### 雪花算法组成

![[Attachments/Pasted image 20240414130713.png]]

包含四个组成部分：

**不使用**：1bit，最高位是符号位，0 表示正，1 表示负，固定为 0。

**时间戳**：41bit，毫秒级的时间戳（41 位的长度可以使用 69 年）。

**标识位**：5bit 数据中心 ID，5bit 工作机器 ID，两个标识位组合起来最多可以支持部署 1024 个节点。

**序列号**：12bit 递增序列号，表示节点毫秒内生成重复，通过序列号表示唯一，12bit 每毫秒可产生 4096 个 ID。

通过序列号 1 毫秒可以产生 4096 个不重复 ID，则 1 秒可以生成 4096 * 1000 = 409w ID。

默认的雪花算法是 64 bit，具体的长度可以自行配置。如果希望运行更久，**增加时间戳的位数**；如果需要支持更多节点部署，**增加标识位长度**；如果并发很高，**增加序列号位数。**

**总结**：雪花算法并不是一成不变的，可以根据系统内具体场景进行定制。

### 优缺点

**SnowFlake 算法的优点：**

1. 高性能高可用：生成时不依赖于数据库，完全在内存中生成。
2. 高吞吐：每秒钟能生成数百万的自增 ID。
3. ID 自增：存入数据库中，索引效率高。

**SnowFlake 算法的缺点：**

依赖与系统时间的一致性，如果系统时间被回调，或者改变，可能会造成 ID 冲突或者重复。

---

**雪花算法生成ID重复的问题**

**假设**：一个订单微服务，通过雪花算法生成 ID，共部署三个节点，标识位一致。

此时有 200 并发，均匀散布三个节点，三个节点同一毫秒同一序列号下生成 ID，那么就会产生重复 ID。

通过上述假设场景，可以知道雪花算法生成 ID 冲突存在一定的前提条件：

1. 服务通过集群的方式部署，其中部分机器标识位一致。
2. 业务存在一定的并发量，没有并发量无法触发重复问题。
3. 生成 ID 的时机：同一毫秒下的序列号一致。

---

### 标识位如何定义

如果能保证标识位不重复，那么雪花 ID 也不会重复。

通过上面的案例，知道了 ID 重复的必要条件。如果要避免服务内产生重复的 ID，那么就需要从标识位上动文章。

MyBatis-Plus里面是根据mac地址计算出来dataCenterId , 然后根据mac地址和pid计算出workerId


### 标识位如何分配

Mybatis-Plus 标识位的获取依赖 Mac 地址和进程 PID，虽然能做到尽量不重复，但仍有小几率。

标识位如何定义才能不重复？有两种方案：**预分配和动态分配。**

**预分配**

应用上线前，统计当前服务的节点数，人工去申请标识位。

这种方案，没有代码开发量，在服务节点固定或者项目少可以使用，但是解决不了服务节点动态扩容性问题。

**动态分配**

通过将标识位存放在 Redis、Zookeeper、MySQL 等中间件，在服务启动的时候去请求标识位，请求后标识位更新为下一个可用的。

可以使用redis里面的lua脚本来实现

两个key , 分别从0-31循环来分配就可以了

![[Attachments/Pasted image 20240424144649.png]]

## 订单延时关闭选型技术

