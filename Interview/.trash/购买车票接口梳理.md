## 根据责任链模式验证参数

1. 验证参数是否为空
2. 验证参数是否有效
3. 验证列车站点库存是否充足

**验证参数是否有效**: 
1. 首先查询车次是否存在
2. 其次查询车次是否已经发售时间内
3. 最后查询车站是否存在车次中,以及车站的顺序是否正确

```java
 public void handler(PurchaseTicketReqDTO requestParam) {
        // 查询购票车次是否存在，通过封装后安全的 Get 方法
        TrainDO trainDO = distributedCache.safeGet(
                TRAIN_INFO + requestParam.getTrainId(),
                TrainDO.class,
                () -> trainMapper.selectById(requestParam.getTrainId()),
                ADVANCE_TICKET_DAY,
                TimeUnit.DAYS);
        if (Objects.isNull(trainDO)) {
            // 如果按照严谨逻辑，类似异常应该记录当前用户的 userid 并发送到风控中心
            // 如果一段时间有过几次的异常，直接封号处理。下述异常同理
            throw new ClientException("请检查车次是否存在");
        }
        // TODO，当前列车数据并没有通过定时任务每天生成最新的，所以需要隔离这个拦截。后期定时生成数据后删除该判断
        if (!EnvironmentUtil.isDevEnvironment()) {
            // 查询车次是否已经发售
            if (new Date().before(trainDO.getSaleTime())) {
                throw new ClientException("列车车次暂未发售");
            }
            // 查询车次是否在有效期内
            if (new Date().after(trainDO.getDepartureTime())) {
                throw new ClientException("列车车次已出发禁止购票");
            }
        }
        // 获取这趟列车所有的站点
        String trainStationStopoverDetailStr = distributedCache.safeGet(
                TRAIN_STATION_STOPOVER_DETAIL + requestParam.getTrainId(),
                String.class,
                () -> {
                    LambdaQueryWrapper<TrainStationDO> queryWrapper = Wrappers.lambdaQuery(TrainStationDO.class)
                            .eq(TrainStationDO::getTrainId, requestParam.getTrainId())
                            .select(TrainStationDO::getDeparture);
                    List<TrainStationDO> actualTrainStationList = trainStationMapper.selectList(queryWrapper);
                    return CollUtil.isNotEmpty(actualTrainStationList) ? JSON.toJSONString(actualTrainStationList) : null;
                },
                ADVANCE_TICKET_DAY,
                TimeUnit.DAYS);
        List<TrainStationDO> trainDOList = JSON.parseArray(trainStationStopoverDetailStr, TrainStationDO.class);
        // 车站是否存在车次中，以及车站的顺序是否正确
        boolean validateStation = validateStation(
                trainDOList.stream().map(TrainStationDO::getDeparture).toList(),
                requestParam.getDeparture(),
                requestParam.getArrival());
        if (!validateStation) {
            throw new ClientException("列车车站数据错误");
        }
    }
```

**验证列车站点库存是否充足** 
1. 首先根据座位类型对乘车人进行分类,获得一个map,key为座位类型,value为乘车人集合
2. 遍历这个map,然后从缓存中获取到对应的票,如果没有那就查询数据库,之前文章已经细讲过
3. 判断余票是否充足

```java
    @Override
    public void handler(PurchaseTicketReqDTO requestParam) {
        // 车次站点是否还有余票。如果用户提交多个乘车人非同一座位类型，拆分验证
        String keySuffix = StrUtil.join("_", requestParam.getTrainId(), requestParam.getDeparture(), requestParam.getArrival());
        StringRedisTemplate stringRedisTemplate = (StringRedisTemplate) distributedCache.getInstance();
        List<PurchaseTicketPassengerDetailDTO> passengerDetails = requestParam.getPassengers();
        // 获取用户的座位类型map,key为座位类型,value为相同座位类型的乘客列表
        Map<Integer, List<PurchaseTicketPassengerDetailDTO>> seatTypeMap = passengerDetails.stream()
                .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType));
        seatTypeMap.forEach((seatType, passengerSeatDetails) -> {
            // 获取缓存中的票数,没有的话就查询,一般会命中,因为在购买之前会先查询,查询的时候就已经调用了
            Object stockObj = stringRedisTemplate.opsForHash().get(TRAIN_STATION_REMAINING_TICKET + keySuffix, String.valueOf(seatType));
            int stock = Optional.ofNullable(stockObj).map(each -> Integer.parseInt(each.toString())).orElseGet(() -> {
                Map<String, String> seatMarginMap =
                        seatMarginCacheLoader.load(String.valueOf(requestParam.getTrainId()), String.valueOf(seatType), requestParam.getDeparture(), requestParam.getArrival());
                return Optional.ofNullable(seatMarginMap.get(String.valueOf(seatType))).map(Integer::parseInt).orElse(0);
            });
            if (stock >= passengerSeatDetails.size()) {
                return;
            }
            // 如果票不充足
            throw new ClientException("列车站点已无余票");
        });
    }
```

## 获取令牌
1. 获取到令牌容器,结构为hash,{prefix+trainId:{起始站点+结束站点+座位类型,票数}},如果不存在那么就加载
2. 准备lua脚本执行数据,先获取到执行的lua脚本,然后统计出每个座位类型需要的数量,最后还要得出需要扣减的站点
3. 执行lua脚本,先判断余量token是否可以满足每个座位类型需要的数量,然后如果满足那么先遍历座位类型,再遍历需要扣减的站点,从令牌容器中减去相应的数量即可

```java
    /**
     * 获取车站间令牌桶中的令牌访问
     * 如果返回 {@link Boolean#TRUE} 代表可以参与接下来的购票下单流程
     * 如果返回 {@link Boolean#FALSE} 代表当前访问出发站点和到达站点令牌已被拿完，无法参与购票下单等逻辑
     *
     * @param requestParam 购票请求参数入参
     * @return 是否获取列车车票余量令牌桶中的令牌，{@link Boolean#TRUE} or {@link Boolean#FALSE}
     */
    public boolean takeTokenFromBucket(PurchaseTicketReqDTO requestParam) {
        //获取列车信息
        TrainDO trainDO = distributedCache.safeGet(
                TRAIN_INFO + requestParam.getTrainId(),
                TrainDO.class,
                () -> trainMapper.selectById(requestParam.getTrainId()),
                ADVANCE_TICKET_DAY,
                TimeUnit.DAYS);
        // 计算列车站点路线关系,获取开始站点和目的站点及中间站点信息
        List<RouteDTO> routeDTOList = trainStationService
                .listTrainStationRoute(requestParam.getTrainId(), trainDO.getStartStation(), trainDO.getEndStation());
        StringRedisTemplate stringRedisTemplate = (StringRedisTemplate) distributedCache.getInstance();
        //令牌容器是hash结构,这是第一个key
        String actualHashKey = TICKET_AVAILABILITY_TOKEN_BUCKET + requestParam.getTrainId();
        Boolean hasKey = distributedCache.hasKey(actualHashKey);
        //缓存中不存在,那么执行加载流程
        if (!hasKey) {
            RLock lock = redissonClient.getLock(String.format(LOCK_TICKET_AVAILABILITY_TOKEN_BUCKET, requestParam.getTrainId()));
            lock.lock();
            try {
                Boolean hasKeyTwo = distributedCache.hasKey(actualHashKey);
                if (!hasKeyTwo) {
                    //获取座位类型集合
                    List<Integer> seatTypes = VehicleTypeEnum.findSeatTypesByCode(trainDO.getTrainType());
                    Map<String, String> ticketAvailabilityTokenMap = new HashMap<>();
                    for (RouteDTO each : routeDTOList) {
                        //获取这两个站点之间对应座位类型有多少张票
                        List<SeatTypeCountDTO> seatTypeCountDTOList = seatMapper.listSeatTypeCount(Long.parseLong(requestParam.getTrainId()), each.getStartStation(), each.getEndStation(), seatTypes);
                        for (SeatTypeCountDTO eachSeatTypeCountDTO : seatTypeCountDTOList) {
                            String buildCacheKey = StrUtil.join("_", each.getStartStation(), each.getEndStation(), eachSeatTypeCountDTO.getSeatType());
                            ticketAvailabilityTokenMap.put(buildCacheKey, String.valueOf(eachSeatTypeCountDTO.getSeatCount()));
                        }
                    }
                    //加入hash结构中,结构是{prefix+trainId:{起始站点_结束站点_座位类型:余量}}
                    stringRedisTemplate.opsForHash().putAll(TICKET_AVAILABILITY_TOKEN_BUCKET + requestParam.getTrainId(), ticketAvailabilityTokenMap);
                }
            } finally {
                lock.unlock();
            }
        }
        //获取到redis执行的lua脚本
        DefaultRedisScript<Long> actual = Singleton.get(LUA_TICKET_AVAILABILITY_TOKEN_BUCKET_PATH, () -> {
            DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
            redisScript.setScriptSource(new ResourceScriptSource(new ClassPathResource(LUA_TICKET_AVAILABILITY_TOKEN_BUCKET_PATH)));
            redisScript.setResultType(Long.class);
            return redisScript;
        });
        Assert.notNull(actual);
        //根据座位类型分组
        Map<Integer, Long> seatTypeCountMap = requestParam.getPassengers().stream()
                .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType, Collectors.counting()));
        //最终结构就是拆分为一个 Map，Key 是座位类型，value 是该座位类型的购票人数
        JSONArray seatTypeCountArray = seatTypeCountMap.entrySet().stream()
                .map(entry -> {
                    JSONObject jsonObject = new JSONObject();
                    jsonObject.put("seatType", String.valueOf(entry.getKey()));
                    jsonObject.put("count", String.valueOf(entry.getValue()));
                    return jsonObject;
                })
                .collect(Collectors.toCollection(JSONArray::new));
        //需要扣减的站点
        List<RouteDTO> takeoutRouteDTOList = trainStationService
                .listTakeoutTrainStationRoute(requestParam.getTrainId(), requestParam.getDeparture(), requestParam.getArrival());
        String luaScriptKey = StrUtil.join("_", requestParam.getDeparture(), requestParam.getArrival());
        Long result = stringRedisTemplate.execute(actual, Lists.newArrayList(actualHashKey, luaScriptKey), JSON.toJSONString(seatTypeCountArray), JSON.toJSONString(takeoutRouteDTOList));
        return result != null && Objects.equals(result, 0L);
    }

```
```lua
--Long result = stringRedisTemplate.execute(actual,
--Lists.newArrayList(actualHashKey, luaScriptKey), 
--JSON.toJSONString(seatTypeCountArray),
--JSON.toJSONString(takeoutRouteDTOList));

-- keys[2]就是用户购买的出发站点和结束站点
local inputString = KEYS[2]
local actualKey = inputString
-- 去除前缀
local colonIndex = string.find(actualKey, ":")
if colonIndex ~= nil then
    actualKey = string.sub(actualKey, colonIndex + 1)
end

--argv[1]是需要扣减的座位类型以及对应的数量
local jsonArrayStr = ARGV[1]
local jsonArray = cjson.decode(jsonArrayStr)

for index, jsonObj in ipairs(jsonArray) do
    local seatType = tonumber(jsonObj.seatType)
    local count = tonumber(jsonObj.count)
    local actualInnerHashKey = actualKey .. "_" .. seatType
    --获取指定座位类型的token余量
    local ticketSeatAvailabilityTokenValue = tonumber(redis.call('hget', KEYS[1], tostring(actualInnerHashKey)))
    --判断是否满足分配
    if ticketSeatAvailabilityTokenValue < count then
        return 1
    end
end

--需要扣减的站点
local alongJsonArrayStr = ARGV[2]
local alongJsonArray = cjson.decode(alongJsonArrayStr)

--遍历座位
for index, jsonObj in ipairs(jsonArray) do
    local seatType = tonumber(jsonObj.seatType)
    local count = tonumber(jsonObj.count)
    --遍历需要扣减的站点
    for indexTwo, alongJsonObj in ipairs(alongJsonArray) do
        local startStation = tostring(alongJsonObj.startStation)
        local endStation = tostring(alongJsonObj.endStation)
        local actualInnerHashKey = startStation .. "_" .. endStation .. "_" .. seatType
        --进行扣减操作
        redis.call('hincrby', KEYS[1], tostring(actualInnerHashKey), -count)
    end
end

return 0

```



## 根据列车和座位类型加锁
1. 根据座位类型对乘车人进行分类
2. 遍历座位类型,获取到lockkey=prefix+trainId+seatType
3. 从Caffeine(java缓存)中获取到可重入锁,如果没有那么就创建,然后再获取分布式锁
4. 将本地锁和分布式锁都放入各自的锁列表中,然后依次遍历锁住
5. 锁住之后调用购票逻辑

```java

/*
* Caffeine 是一个 Java 缓存库，用于在应用程序中实现高效的内存缓存。
* 它提供了一个功能强大而高性能的缓存实现，可以用于缓存各种类型的数据，如对象、方法调用的结果等。
* */
private final Cache<String, ReentrantLock> localLockMap = Caffeine.newBuilder()
        .expireAfterWrite(1, TimeUnit.DAYS)
        .build();

@Override
public TicketPurchaseRespDTO purchaseTicketsV2(PurchaseTicketReqDTO requestParam) {
    // 责任链模式，验证 1：参数必填 2：参数正确性 3：乘客是否已买当前车次等...
    purchaseTicketAbstractChainContext.handler(TicketChainMarkEnum.TRAIN_PURCHASE_TICKET_FILTER.name(), requestParam);
    boolean tokenResult = ticketAvailabilityTokenBucket.takeTokenFromBucket(requestParam);
    if (!tokenResult) {
        throw new ServiceException("列车站点已无余票");
    }
    List<ReentrantLock> localLockList = new ArrayList<>();
    List<RLock> distributedLockList = new ArrayList<>();
    //根据座位类型分类
    Map<Integer, List<PurchaseTicketPassengerDetailDTO>> seatTypeMap = requestParam.getPassengers().stream()
            .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType));
    seatTypeMap.forEach((searType, count) -> {
        //key=train id + seat type
        String lockKey = environment.resolvePlaceholders(String.format(LOCK_PURCHASE_TICKETS_V2, requestParam.getTrainId(), searType));
        /*  ReentrantLock 的名称 "Reentrant" 指的是它是可重入的。可重入性是指同一线程可以多次获得同一把锁而不会产生死锁。
         当一个线程已经获得了锁时，它可以继续多次获得该锁而不被阻塞，而其他线程在获取该锁时会被阻塞。*/
        //从java缓存中获取锁
        ReentrantLock localLock = localLockMap.getIfPresent(lockKey);
        //如果没有
        if (localLock == null) {
            //那么在创建锁之前先锁住
            synchronized (TicketService.class) {
                //双重判定
                if ((localLock = localLockMap.getIfPresent(lockKey)) == null) {
                    //这里才创建
                    localLock = new ReentrantLock(true);
                    localLockMap.put(lockKey, localLock);
                }
            }
        }
        //加入到本地锁列表
        localLockList.add(localLock);
        //获取分布式锁
        RLock distributedLock = redissonClient.getFairLock(lockKey);
        //加入分布式锁列表
        distributedLockList.add(distributedLock);
    });
    try {
        localLockList.forEach(ReentrantLock::lock);
        distributedLockList.forEach(RLock::lock);
        //用所有的本地锁和分布式锁都锁住,然后就可以执行购票了
        return executePurchaseTickets(requestParam);
    } finally {
        //最后解锁即可
        localLockList.forEach(localLock -> {
            try {
                localLock.unlock();
            } catch (Throwable ignored) {
            }
        });
        distributedLockList.forEach(distributedLock -> {
            try {
                distributedLock.unlock();
            } catch (Throwable ignored) {
            }
        });
    }
}
```

## 分配并锁定座位

1. 根据座位类型对乘车人进行分类
2. 如果有多个座位类型,那么使用并行流执行分配任务
3. 如果只有一个座位类型那么直接执行就好了
4. 根据列车类型和座位类型构建出策略模式的Mark,选择对应的分配策略执行选座位,以下使用高铁+商务座解释分配座位的逻辑
5. 座位选择完毕之后扣减余票缓存
6. 远程调用获取乘车人的信息,将分配到的座位和乘车人信息进行组装,并且查询train_station_price中这个座位的价格
7. 锁定沿途车站对应的车票

```java
    public List<TrainPurchaseTicketRespDTO> select(Integer trainType, PurchaseTicketReqDTO requestParam) {
        List<PurchaseTicketPassengerDetailDTO> passengerDetails = requestParam.getPassengers();
        //这里也是根据用户的座位类型来进行分类
        Map<Integer, List<PurchaseTicketPassengerDetailDTO>> seatTypeMap = passengerDetails.stream()
                .collect(Collectors.groupingBy(PurchaseTicketPassengerDetailDTO::getSeatType));
        //这里是真实统计票价和票位的地方
        List<TrainPurchaseTicketRespDTO> actualResult = new CopyOnWriteArrayList<>();
        //如果有多个座位类型
        if (seatTypeMap.size() > 1) {
            //开一个线程池
            List<Future<List<TrainPurchaseTicketRespDTO>>> futureResults = new ArrayList<>();
            //遍历所有的座位类型map
            seatTypeMap.forEach((seatType, passengerSeatDetails) -> {
                //得到一个Future对象,里面是分配任务的座位
                Future<List<TrainPurchaseTicketRespDTO>> completableFuture = selectSeatThreadPoolExecutor
                        .submit(() -> distributeSeats(trainType, seatType, requestParam, passengerSeatDetails));
                //加入线程数组中
                futureResults.add(completableFuture);
            });
            //并行流执行任务获取到所有的结果然后加入actualResult里面
            futureResults.parallelStream().forEach(completableFuture -> {
                try {
                    actualResult.addAll(completableFuture.get());
                } catch (Exception e) {
                    throw new ServiceException("站点余票不足，请尝试更换座位类型或选择其它站点");
                }
            });
            //如果只有一个座位类型,那就不需要使用并行流,直接执行就好了
        } else {
            seatTypeMap.forEach((seatType, passengerSeatDetails) -> {
                List<TrainPurchaseTicketRespDTO> aggregationResult = distributeSeats(trainType, seatType, requestParam, passengerSeatDetails);
                actualResult.addAll(aggregationResult);
            });
        }
        //判断是否座位分配成功
        if (CollUtil.isEmpty(actualResult) || !Objects.equals(actualResult.size(), passengerDetails.size())) {
            throw new ServiceException("站点余票不足，请尝试更换座位类型或选择其它站点");
        }
        //获取乘车人的id集合
        List<String> passengerIds = actualResult.stream()
                .map(TrainPurchaseTicketRespDTO::getPassengerId)
                .collect(Collectors.toList());
        //远程调用user-service来获取乘车人的信息集合
        Result<List<PassengerRespDTO>> passengerRemoteResult;
        List<PassengerRespDTO> passengerRemoteResultList;
        try {
            //远程调用获取乘车人的信息
            passengerRemoteResult = userRemoteService.listPassengerQueryByIds(UserContext.getUsername(), passengerIds);
            if (!passengerRemoteResult.isSuccess() || CollUtil.isEmpty(passengerRemoteResultList = passengerRemoteResult.getData())) {
                throw new RemoteException("用户服务远程调用查询乘车人相信信息错误");
            }
        } catch (Throwable ex) {
            if (ex instanceof RemoteException) {
                log.error("用户服务远程调用查询乘车人相信信息错误，当前用户：{}，请求参数：{}", UserContext.getUsername(), passengerIds);
            } else {
                log.error("用户服务远程调用查询乘车人相信信息错误，当前用户：{}，请求参数：{}", UserContext.getUsername(), passengerIds, ex);
            }
            throw ex;
        }
        //需要将获得的票价票位和乘车人信息进行组装返回结果
        actualResult.forEach(each -> {
            //找到远程获得的乘车人信息里面的id相同的提取出来需要的信息
            String passengerId = each.getPassengerId();
            passengerRemoteResultList.stream()
                    .filter(item -> Objects.equals(item.getId(), passengerId))
                    .findFirst()
                    .ifPresent(passenger -> {
                        each.setIdCard(passenger.getIdCard());
                        each.setPhone(passenger.getPhone());
                        each.setUserType(passenger.getDiscountType());
                        each.setIdType(passenger.getIdType());
                        each.setRealName(passenger.getRealName());
                    });
            //获取到这个位置的票价
            LambdaQueryWrapper<TrainStationPriceDO> lambdaQueryWrapper = Wrappers.lambdaQuery(TrainStationPriceDO.class)
                    .eq(TrainStationPriceDO::getTrainId, requestParam.getTrainId())
                    .eq(TrainStationPriceDO::getDeparture, requestParam.getDeparture())
                    .eq(TrainStationPriceDO::getArrival, requestParam.getArrival())
                    .eq(TrainStationPriceDO::getSeatType, each.getSeatType())
                    .select(TrainStationPriceDO::getPrice);
            TrainStationPriceDO trainStationPriceDO = trainStationPriceMapper.selectOne(lambdaQueryWrapper);
            each.setAmount(trainStationPriceDO.getPrice());
        });
        //锁定沿途车站的对应的车票
        seatService.lockSeat(requestParam.getTrainId(), requestParam.getDeparture(), requestParam.getArrival(), actualResult);
        return actualResult;
    }
```

### 高铁+商务座的分配座位的逻辑

1. 首先查询出这趟列车的这种座位类型的有余票的车厢列表
2. 然后获取这些车厢的余票的数量的列表
3. 对所有车厢余票求和,如果票数不够就抛出异常
4. 如果乘客选择了座位类型,那么执行findMatchSeats方法尽量选择匹配的座位
5. 乘客没有选择座位类型,如果购票人数为1-2人那么就执行selectSeats方法,3人及以上就需要执行selectComplexSeats方法

**findMatchSeats**
1. 遍历每一个车厢
2. 对于这个车厢,获取到这个车厢所有的可以选择的座位的集合,然后将车厢看做一个二维平面,将每个座位映射成点,然后根据可以选择的座位的集合构建出一个二维数组actualSeats,代表着座位是否可用
3. 判断这个车厢的可用座位是否可以满足用户选择的座位类型
4. 如果这节车厢可以满足用户的选择的类型,那么就遍历用户选择的座位类型,然后根据座位是否可用表找到可以用的座位,找到了之后添加入结果中,然后在空闲座位表中移除这个座位
5. 如果这节车厢不可以满足用户选择的类型,那么如果不是最后一节车厢,就继续遍历,但是把得到的车厢的可用座位列表存起来
6. 一直到最后一节车厢,那么就可以进行处理了.遍历之前存起来的Map<车厢号,可用座位列表>,如果有某一节车厢的可用座位大雨了乘客数量,那么就全部加入,返回结果
7. 如果map遍历完了都没有结果,那么说明我们需要分散分配了,再次遍历车厢,这节车厢有空余位置就分配,依次直到分配满,返回结果即可

```java
private Pair<List<TrainPurchaseTicketRespDTO>, Boolean> findMatchSeats(SelectSeatDTO requestParam, List<String> trainCarriageList, List<Integer> trainStationCarriageRemainingTicket) {
        //转化一个参数
        TrainSeatBaseDTO trainSeatBaseDTO = buildTrainSeatBaseDTO(requestParam);
        //获取选择座位的数量
        int chooseSeatSize = trainSeatBaseDTO.getChooseSeatList().size();
        //这里是真正的买票返回结果,里面有金额和车厢号和座位号和其他乘车人的基本信息
        List<TrainPurchaseTicketRespDTO> actualResult = Lists.newArrayListWithCapacity(trainSeatBaseDTO.getPassengerSeatDetails().size());
        //获取检查是否有座位的实例对象,这里获取的是商务座的,因为这里是高铁的商务座车票购买策略
        BitMapCheckSeat instance = BitMapCheckSeatStatusFactory.getInstance(TRAIN_BUSINESS);
        //
        HashMap<String, List<Pair<Integer, Integer>>> carriagesSeatMap = new HashMap<>(4);
        //获取乘车人的数量
        int passengersNumber = trainSeatBaseDTO.getPassengerSeatDetails().size();
        //遍历每一个车厢
        for (int i = 0; i < trainStationCarriageRemainingTicket.size(); i++) {
            //获取车厢id
            String carriagesNumber = trainCarriageList.get(i);
            //获取对应车厢id里面的所有可选择的座位,会得到seatNumber的集合
            List<String> listAvailableSeat = seatService.listAvailableSeat(trainSeatBaseDTO.getTrainId(), carriagesNumber, requestParam.getSeatType(), trainSeatBaseDTO.getDeparture(), trainSeatBaseDTO.getArrival());
            //复兴号商务座只有两排一共六个座位,但是有一个不可售
            int[][] actualSeats = new int[2][3];
            //记录是否有下面这些座位类型,如果有那么值为0
            //01A 01C(不可售) 01F
            //02A 02C 02F
            for (int j = 1; j < 3; j++) {
                for (int k = 1; k < 4; k++) {
                    actualSeats[j - 1][k - 1] = listAvailableSeat.contains("0" + j + SeatNumberUtil.convert(0, k)) ? 0 : 1;
                }
            }
            //将上面的actualSeats数组进行处理,过滤出值为0的数组,也就是有空闲座位的数组
            List<Pair<Integer, Integer>> vacantSeatList = CarriageVacantSeatCalculateUtil.buildCarriageVacantSeatList2(actualSeats, 2, 3);
            //判断这节车厢真实存在的座位列表是否可以满足用户选择的座位列表
            boolean isExists = instance.checkChooseSeat(trainSeatBaseDTO.getChooseSeatList(), actualSeats, SEAT_Y_INT);
            //得到空闲座位的数量
            long vacantSeatCount = vacantSeatList.size();
            //这里存放的是座位号的二维坐标
            List<Pair<Integer, Integer>> sureSeatList = new ArrayList<>();
            //这里存放的是座位号
            List<String> selectSeats = Lists.newArrayListWithCapacity(passengersNumber);
            //这个flag标志了只购买一张票并且还没有预定类型的票的情况
            boolean flag = false;
            //如果在这节车厢可以满足用户的选择位置
            if (isExists && vacantSeatCount >= passengersNumber) {
                Iterator<Pair<Integer, Integer>> pairIterator = vacantSeatList.iterator();
                //遍历用户选择的座位
                for (int i1 = 0; i1 < chooseSeatSize; i1++) {
                    //如果只选择了一个座位
                    if (chooseSeatSize == 1) {
                        //获取到这个座位的排号和列号
                        String chooseSeat = trainSeatBaseDTO.getChooseSeatList().get(i1);
                        int seatX = Integer.parseInt(chooseSeat.substring(1));
                        int seatY = SEAT_Y_INT.get(chooseSeat.charAt(0));
                        //如果这个座位真实可用
                        if (actualSeats[seatX][seatY] == 0) {
                            //那么就加入确保可用的座位的list中
                            sureSeatList.add(new Pair<>(seatX, seatY));
                            //然后在空闲座位里面找到对应的座位,删去即可
                            while (pairIterator.hasNext()) {
                                Pair<Integer, Integer> pair = pairIterator.next();
                                if (pair.getKey() == seatX && pair.getValue() == seatY) {
                                    pairIterator.remove();
                                    break;
                                }
                            }
                        } else {
                            //如果客户预定的座位不可用,那么如果另一个座位有用
                            if (actualSeats[1][seatY] == 0) {
                                //将可用座位加入然后才空闲中删除即可
                                sureSeatList.add(new Pair<>(1, seatY));
                                while (pairIterator.hasNext()) {
                                    Pair<Integer, Integer> pair = pairIterator.next();
                                    if (pair.getKey() == 1 && pair.getValue() == seatY) {
                                        pairIterator.remove();
                                        break;
                                    }
                                }
                            } else {
                                flag = true;
                            }
                        }
                    } else {
                        //选择了多个座位就会走这里
                        String chooseSeat = trainSeatBaseDTO.getChooseSeatList().get(i1);
                        int seatX = Integer.parseInt(chooseSeat.substring(1));
                        int seatY = SEAT_Y_INT.get(chooseSeat.charAt(0));
                        //如果这个可用那么更新
                        if (actualSeats[seatX][seatY] == 0) {
                            sureSeatList.add(new Pair<>(seatX, seatY));
                            while (pairIterator.hasNext()) {
                                Pair<Integer, Integer> pair = pairIterator.next();
                                if (pair.getKey() == seatX && pair.getValue() == seatY) {
                                    pairIterator.remove();
                                    break;
                                }
                            }
                        }
                    }
                }
                //遍历完了这节车厢里面的座位之后,如果出现flag为true(也就是一个人买票并且没买到对应类型的),并且后面还有车厢,那么continue
                //ps: 感觉不会执行这行代码,因为上面保证了existed然后已经可以正常分配吧
                if (flag && i < trainStationCarriageRemainingTicket.size() - 1) {
                    continue;
                }
                //如果在之前车厢已经买到票的数量和乘客数量不同,那么加没买到票的数量的票进去,因为这节车厢是可以满足用户的购票需求的
                //ps: 感觉也不会执行
                if (sureSeatList.size() != passengersNumber) {
                    int needSeatSize = passengersNumber - sureSeatList.size();
                    sureSeatList.addAll(vacantSeatList.subList(0, needSeatSize));
                }
                //将已购的座位转化一下成为真实返回的座位
                for (Pair<Integer, Integer> each : sureSeatList) {
                    selectSeats.add("0" + (each.getKey() + 1) + SeatNumberUtil.convert(0, (each.getValue() + 1)));
                }
                AtomicInteger countNum = new AtomicInteger(0);
                //对于所有已购的座位,组装好返回值
                for (String selectSeat : selectSeats) {
                    TrainPurchaseTicketRespDTO result = new TrainPurchaseTicketRespDTO();
                    PurchaseTicketPassengerDetailDTO currentTicketPassenger = trainSeatBaseDTO.getPassengerSeatDetails().get(countNum.getAndIncrement());
                    result.setSeatNumber(selectSeat);
                    result.setSeatType(currentTicketPassenger.getSeatType());
                    result.setCarriageNumber(carriagesNumber);
                    result.setPassengerId(currentTicketPassenger.getPassengerId());
                    actualResult.add(result);
                }
                return new Pair<>(actualResult, Boolean.TRUE);
            } else {
                //以下是这节车厢里面不能够满足用户的购票需求了
                if (i < trainStationCarriageRemainingTicket.size()) {
                    //如果还有空闲座位,放进去,这里存放的是每一节车厢的可用座位列表Map
                    if (vacantSeatCount > 0) {
                        carriagesSeatMap.put(carriagesNumber, vacantSeatList);
                    }
                    //如果到这里是最后一节车厢,那么可以进行处理了
                    if (i == trainStationCarriageRemainingTicket.size() - 1) {
                        Pair<String, List<Pair<Integer, Integer>>> findSureCarriage = null;
                        //如果有某一节车厢的可用座位大于了乘客数量,那么就全加入
                        for (Map.Entry<String, List<Pair<Integer, Integer>>> entry : carriagesSeatMap.entrySet()) {
                            if (entry.getValue().size() >= passengersNumber) {
                                findSureCarriage = new Pair<>(entry.getKey(), entry.getValue().subList(0, passengersNumber));
                                break;
                            }
                        }
                        //如果这里成立,说明乘客被分配到了同一个车厢
                        if (null != findSureCarriage) {
                            //取出来
                            sureSeatList = findSureCarriage.getValue().subList(0, passengersNumber);
                            //映射
                            for (Pair<Integer, Integer> each : sureSeatList) {
                                selectSeats.add("0" + (each.getKey() + 1) + SeatNumberUtil.convert(0, each.getValue() + 1));
                            }
                            //然后组装成返回结果
                            AtomicInteger countNum = new AtomicInteger(0);
                            for (String selectSeat : selectSeats) {
                                TrainPurchaseTicketRespDTO result = new TrainPurchaseTicketRespDTO();
                                PurchaseTicketPassengerDetailDTO currentTicketPassenger = trainSeatBaseDTO.getPassengerSeatDetails().get(countNum.getAndIncrement());
                                result.setSeatNumber(selectSeat);
                                result.setSeatType(currentTicketPassenger.getSeatType());
                                result.setCarriageNumber(findSureCarriage.getKey());
                                result.setPassengerId(currentTicketPassenger.getPassengerId());
                                actualResult.add(result);
                            }
                        } else {
                            //走到这里说明乘客没有被分配到同一个车厢里面
                            int sureSeatListSize = 0;
                            AtomicInteger countNum = new AtomicInteger(0);
                            //那么只能分散来了,所以就是遍历车厢
                            for (Map.Entry<String, List<Pair<Integer, Integer>>> entry : carriagesSeatMap.entrySet()) {
                                //如果购票没满
                                if (sureSeatListSize < passengersNumber) {
                                    //如果全加上都不够的话,那么就直接全加上
                                    if (sureSeatListSize + entry.getValue().size() < passengersNumber) {
                                        sureSeatListSize = sureSeatListSize + entry.getValue().size();
                                        List<String> actualSelectSeats = new ArrayList<>();
                                        for (Pair<Integer, Integer> each : entry.getValue()) {
                                            actualSelectSeats.add("0" + (each.getKey() + 1) + SeatNumberUtil.convert(0, each.getValue() + 1));
                                        }
                                        for (String selectSeat : actualSelectSeats) {
                                            TrainPurchaseTicketRespDTO result = new TrainPurchaseTicketRespDTO();
                                            PurchaseTicketPassengerDetailDTO currentTicketPassenger = trainSeatBaseDTO.getPassengerSeatDetails().get(countNum.getAndIncrement());
                                            result.setSeatNumber(selectSeat);
                                            result.setSeatType(currentTicketPassenger.getSeatType());
                                            result.setCarriageNumber(entry.getKey());
                                            result.setPassengerId(currentTicketPassenger.getPassengerId());
                                            actualResult.add(result);
                                        }
                                    } else {
                                        //否则就加上差值就好了
                                        int needSeatSize = entry.getValue().size() - (sureSeatListSize + entry.getValue().size() - passengersNumber);
                                        sureSeatListSize = sureSeatListSize + needSeatSize;
                                        if (sureSeatListSize >= passengersNumber) {
                                            List<String> actualSelectSeats = new ArrayList<>();
                                            for (Pair<Integer, Integer> each : entry.getValue().subList(0, needSeatSize)) {
                                                actualSelectSeats.add("0" + (each.getKey() + 1) + SeatNumberUtil.convert(0, each.getValue() + 1));
                                            }
                                            for (String selectSeat : actualSelectSeats) {
                                                TrainPurchaseTicketRespDTO result = new TrainPurchaseTicketRespDTO();
                                                PurchaseTicketPassengerDetailDTO currentTicketPassenger = trainSeatBaseDTO.getPassengerSeatDetails().get(countNum.getAndIncrement());
                                                result.setSeatNumber(selectSeat);
                                                result.setSeatType(currentTicketPassenger.getSeatType());
                                                result.setCarriageNumber(entry.getKey());
                                                result.setPassengerId(currentTicketPassenger.getPassengerId());
                                                actualResult.add(result);
                                            }
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                        return new Pair<>(actualResult, Boolean.TRUE);
                    }
                }
            }
        }
        return new Pair<>(null, Boolean.FALSE);
    }
```

**selectSeats**

1. 遍历车厢
2. 获取有用的座位集合,然后做数组映射actualSeats
3. 然后根据乘车人的数量和座位是否可用表直接查找相邻的座位,判断方法比较简单,就是横向遍历,空+1,非空置0,如果值为乘车人的数量,那么倒序收集座位即可
4. 如果这个车厢不满足那么就转到下一个车厢,思想就是优先同车厢相邻,因为最多两个人.在离开这节车厢之前收集一下这节车厢剩下的空位数量以及车厢的座位是否可用表
5. 一直到最后一节车厢如果还是不能满足同车厢相邻,那么进行降级分配,改成同车厢不相邻.遍历车厢根据之前统计的车厢空位数量以及座位是否可用表,可以根据不相邻分配算法(也就是遍历,碰到空位就选择)得到座位,找到合适的就返回
6. 如果同车厢不邻座也不能满足,那么就执行不同车厢不邻座的算法
7. 最后返回结果

```java
    private List<TrainPurchaseTicketRespDTO> selectSeats(SelectSeatDTO requestParam, List<String> trainCarriageList, List<Integer> trainStationCarriageRemainingTicket) {
        //拆分出参数
        String trainId = requestParam.getRequestParam().getTrainId();
        String departure = requestParam.getRequestParam().getDeparture();
        String arrival = requestParam.getRequestParam().getArrival();
        List<PurchaseTicketPassengerDetailDTO> passengerSeatDetails = requestParam.getPassengerSeatDetails();
        List<TrainPurchaseTicketRespDTO> actualResult = new ArrayList<>();
        Map<String, Integer> demotionStockNumMap = new LinkedHashMap<>();
        Map<String, int[][]> actualSeatsMap = new HashMap<>();
        Map<String, int[][]> carriagesNumberSeatsMap = new HashMap<>();
        String carriagesNumber;
        //遍历车厢
        for (int i = 0; i < trainStationCarriageRemainingTicket.size(); i++) {
            carriagesNumber = trainCarriageList.get(i);
            //获取可用的座位集合
            List<String> listAvailableSeat = seatService.listAvailableSeat(trainId, carriagesNumber, requestParam.getSeatType(), departure, arrival);
            //标记是否可用
            int[][] actualSeats = new int[2][3];
            for (int j = 1; j < 3; j++) {
                for (int k = 1; k < 4; k++) {
                    // 当前默认按照复兴号商务座排序，后续这里需要按照简单工厂对车类型进行获取 y 轴
                    actualSeats[j - 1][k - 1] = listAvailableSeat.contains("0" + j + SeatNumberUtil.convert(0, k)) ? 0 : 1;
                }
            }
            //直接查找相邻的
            int[][] select = SeatSelection.adjacent(passengerSeatDetails.size(), actualSeats);
            if (select != null) {
                carriagesNumberSeatsMap.put(carriagesNumber, select);
                break;
            }
            //如果这个车厢没找到那么就记录下后面需要用的数据
            //也就是每个车厢剩下的空位数量还有他们的座位是否可用表
            int demotionStockNum = 0;
            for (int[] actualSeat : actualSeats) {
                for (int i1 : actualSeat) {
                    if (i1 == 0) {
                        demotionStockNum++;
                    }
                }
            }
            demotionStockNumMap.putIfAbsent(carriagesNumber, demotionStockNum);
            actualSeatsMap.putIfAbsent(carriagesNumber, actualSeats);
            //不到最后一节车厢都继续continue
            if (i < trainStationCarriageRemainingTicket.size() - 1) {
                continue;
            }
            //走到这里说明一直到了最后一节车厢都不能够满足两个人购买同一个车厢的相邻座位
            // 如果邻座算法无法匹配，尝试对用户进行降级分配：同车厢不邻座
            for (Map.Entry<String, Integer> entry : demotionStockNumMap.entrySet()) {
                String carriagesNumberBack = entry.getKey();
                int demotionStockNumBack = entry.getValue();
                if (demotionStockNumBack > passengerSeatDetails.size()) {
                    int[][] seats = actualSeatsMap.get(carriagesNumberBack);
                    int[][] nonAdjacentSeats = SeatSelection.nonAdjacent(passengerSeatDetails.size(), seats);
                    if (Objects.equals(nonAdjacentSeats.length, passengerSeatDetails.size())) {
                        select = nonAdjacentSeats;
                        carriagesNumberSeatsMap.put(carriagesNumberBack, select);
                        break;
                    }
                }
            }
            // 如果同车厢不邻座也已无法匹配，则对用户座位再次降级：不同车厢不邻座
            //此时肯定是每个车厢里面要么满了要么只有一个座位
            if (Objects.isNull(select)) {
                for (Map.Entry<String, Integer> entry : demotionStockNumMap.entrySet()) {
                    String carriagesNumberBack = entry.getKey();
                    int demotionStockNumBack = entry.getValue();
                    int[][] seats = actualSeatsMap.get(carriagesNumberBack);
                    int[][] nonAdjacentSeats = SeatSelection.nonAdjacent(demotionStockNumBack, seats);
                    carriagesNumberSeatsMap.put(entry.getKey(), nonAdjacentSeats);
                }
            }
        }
        int count = (int) carriagesNumberSeatsMap.values().stream()
                .flatMap(Arrays::stream)
                .count();
        //解析并且构建出返回参数
        if (CollUtil.isNotEmpty(carriagesNumberSeatsMap) && passengerSeatDetails.size() == count) {
            int countNum = 0;
            for (Map.Entry<String, int[][]> entry : carriagesNumberSeatsMap.entrySet()) {
                List<String> selectSeats = new ArrayList<>();
                for (int[] ints : entry.getValue()) {
                    selectSeats.add("0" + ints[0] + SeatNumberUtil.convert(0, ints[1]));
                }
                for (String selectSeat : selectSeats) {
                    TrainPurchaseTicketRespDTO result = new TrainPurchaseTicketRespDTO();
                    PurchaseTicketPassengerDetailDTO currentTicketPassenger = passengerSeatDetails.get(countNum++);
                    result.setSeatNumber(selectSeat);
                    result.setSeatType(currentTicketPassenger.getSeatType());
                    result.setCarriageNumber(entry.getKey());
                    result.setPassengerId(currentTicketPassenger.getPassengerId());
                    actualResult.add(result);
                }
            }
        }
        return actualResult;
    }
```

**selectCOmplexSeats**
1. 遍历车厢
2. 获取座位是否可用表,将乘车人按照每两个分成一组,然后遍历乘车人的分组,根据相邻算法分配给乘车人,然后记录下选择的座位,如果所有的乘车人都在这一节车厢被处理了,才是符合这次遍历的分配(同车厢相邻),将获得的座位列表数组merge,否则就记录车厢的剩余座位列表
3. 如果同车厢邻座不能满足,那么就同车厢不邻座,找到第一个剩余座位数量大于乘车人数量的车厢然后使用不相邻算法挑选座位即可
4. 如果同车厢也无法分配,那么不同车厢不邻座,依次填满车厢直到满足即可
5. 最后返回结果

```java
    private List<TrainPurchaseTicketRespDTO> selectComplexSeats(SelectSeatDTO requestParam, List<String> trainCarriageList, List<Integer> trainStationCarriageRemainingTicket) {
        //拆分参数
        String trainId = requestParam.getRequestParam().getTrainId();
        String departure = requestParam.getRequestParam().getDeparture();
        String arrival = requestParam.getRequestParam().getArrival();
        List<PurchaseTicketPassengerDetailDTO> passengerSeatDetails = requestParam.getPassengerSeatDetails();
        List<TrainPurchaseTicketRespDTO> actualResult = new ArrayList<>();
        //降级map
        Map<String, Integer> demotionStockNumMap = new LinkedHashMap<>();
        Map<String, int[][]> actualSeatsMap = new HashMap<>();
        Map<String, int[][]> carriagesNumberSeatsMap = new HashMap<>();
        String carriagesNumber;
        // 多人分配同一车厢邻座
        for (int i = 0; i < trainStationCarriageRemainingTicket.size(); i++) {
            //获取车厢号
            carriagesNumber = trainCarriageList.get(i);
            //获取对应车厢号里面的可用的座位列表
            List<String> listAvailableSeat = seatService.listAvailableSeat(trainId, carriagesNumber, requestParam.getSeatType(), departure, arrival);
            //获取座位是否可用
            //01A 01C 01F
            //02A 02C 02F
            int[][] actualSeats = new int[2][3];
            for (int j = 1; j < 3; j++) {
                for (int k = 1; k < 4; k++) {
                    // 当前默认按照复兴号商务座排序，后续这里需要按照简单工厂对车类型进行获取 y 轴
                    actualSeats[j - 1][k - 1] = listAvailableSeat.contains("0" + j + SeatNumberUtil.convert(0, k)) ? 0 : 1;
                }
            }
            //拷贝一份
            int[][] actualSeatsTranscript = deepCopy(actualSeats);
            List<int[][]> actualSelects = new ArrayList<>();
            //将乘车人按照每两个分成一组
            List<List<PurchaseTicketPassengerDetailDTO>> splitPassengerSeatDetails = ListUtil.split(passengerSeatDetails, 2);
            for (List<PurchaseTicketPassengerDetailDTO> each : splitPassengerSeatDetails) {
                //将座位列表是否可用和乘车人size(1或2)传过去,返回相邻的座位
                int[][] select = SeatSelection.adjacent(each.size(), actualSeatsTranscript);
                if (select != null) {
                    for (int[] ints : select) {
                        //把标记座位是否可用的副本 的对应分配位置置1,表示不可用了,已经被选取了
                        actualSeatsTranscript[ints[0] - 1][ints[1] - 1] = 1;
                    }
                    actualSelects.add(select);
                }
            }
            //因为每成功处理一个分组,actualSelects都会添加一个数组进去,所以相等代表全部处理完成了
            if (actualSelects.size() == splitPassengerSeatDetails.size()) {
                int[][] actualSelect = null;
                for (int j = 0; j < actualSelects.size(); j++) {
                    //第一项就是将自己和后一项merge一下
                    if (j == 0) {
                        actualSelect = mergeArrays(actualSelects.get(j), actualSelects.get(j + 1));
                    }
                    //后面的项就是将前面合并得到的actualSelect和后面一项merge
                    if (j != 0 && actualSelects.size() > 2) {
                        actualSelect = mergeArrays(actualSelect, actualSelects.get(j + 1));
                    }
                }
                //车厢序号:已选择的座位列表 <- Map
                //只有所有的乘车人都在这个车厢里面被相邻算法安排,才会放入
                carriagesNumberSeatsMap.put(carriagesNumber, actualSelect);
                break;
            }
            //这里是建立在所有的乘车人在这个车厢里面无法被相邻算法安排
            //如果相邻算法不能够安排好的话,所有的车厢都会被遍历,这里就可以统计完全供后面两种算法使用
            //统计出车厢中剩余的座位
            int demotionStockNum = 0;
            for (int[] actualSeat : actualSeats) {
                for (int i1 : actualSeat) {
                    if (i1 == 0) {
                        demotionStockNum++;
                    }
                }
            }
            //放入map中
            demotionStockNumMap.putIfAbsent(carriagesNumber, demotionStockNum);
            actualSeatsMap.putIfAbsent(carriagesNumber, actualSeats);
        }
        // 如果邻座算法无法匹配，尝试对用户进行降级分配：同车厢不邻座
        if (CollUtil.isEmpty(carriagesNumberSeatsMap)) {
            for (Map.Entry<String, Integer> entry : demotionStockNumMap.entrySet()) {
                String carriagesNumberBack = entry.getKey();
                int demotionStockNumBack = entry.getValue();
                //如果车厢中剩余的票大于乘车人数量,那么就可以安排了
                if (demotionStockNumBack > passengerSeatDetails.size()) {
                    int[][] seats = actualSeatsMap.get(carriagesNumberBack);
                    int[][] nonAdjacentSeats = SeatSelection.nonAdjacent(passengerSeatDetails.size(), seats);
                    if (Objects.equals(nonAdjacentSeats.length, passengerSeatDetails.size())) {
                        //只有满足数量才会被放入
                        carriagesNumberSeatsMap.put(carriagesNumberBack, nonAdjacentSeats);
                        break;
                    }
                }
            }
        }
        // 如果同车厢也已无法匹配，则对用户座位再次降级：不同车厢不邻座
        if (CollUtil.isEmpty(carriagesNumberSeatsMap)) {
            //未分配的乘客的数量
            int undistributedPassengerSize = passengerSeatDetails.size();
            for (Map.Entry<String, Integer> entry : demotionStockNumMap.entrySet()) {
                String carriagesNumberBack = entry.getKey();
                int demotionStockNumBack = entry.getValue();
                int[][] seats = actualSeatsMap.get(carriagesNumberBack);
                //从未分配乘客数量和车厢中可分配数量取最小值
                int[][] nonAdjacentSeats = SeatSelection.nonAdjacent(Math.min(undistributedPassengerSize, demotionStockNumBack), seats);
                //更新未分配数量
                undistributedPassengerSize = undistributedPassengerSize - demotionStockNumBack;
                carriagesNumberSeatsMap.put(entry.getKey(), nonAdjacentSeats);
            }
        }
        // 乘车人员在单一车厢座位不满足，触发乘车人元分布在不同车厢
        int count = (int) carriagesNumberSeatsMap.values().stream()
                .flatMap(Arrays::stream)
                .count();
        if (CollUtil.isNotEmpty(carriagesNumberSeatsMap) && passengerSeatDetails.size() == count) {
            int countNum = 0;
            for (Map.Entry<String, int[][]> entry : carriagesNumberSeatsMap.entrySet()) {
                //获取每一个车厢的真实选择的座位号组装
                List<String> selectSeats = new ArrayList<>();
                for (int[] ints : entry.getValue()) {
                    selectSeats.add("0" + ints[0] + SeatNumberUtil.convert(0, ints[1]));
                }
                for (String selectSeat : selectSeats) {
                    TrainPurchaseTicketRespDTO result = new TrainPurchaseTicketRespDTO();
                    PurchaseTicketPassengerDetailDTO currentTicketPassenger = passengerSeatDetails.get(countNum++);
                    result.setSeatNumber(selectSeat);
                    result.setSeatType(currentTicketPassenger.getSeatType());
                    result.setCarriageNumber(entry.getKey());
                    result.setPassengerId(currentTicketPassenger.getPassengerId());
                    actualResult.add(result);
                }
            }
        }
        return actualResult;
    }
```

**补充邻座选择器和非邻座选择器**
```java
    public static int[][] adjacent(int numSeats, int[][] seatLayout) {
        //获取行和列
        int numRows = seatLayout.length;
        int numCols = seatLayout[0].length;
        List<int[]> selectedSeats = new ArrayList<>();
        //然后
        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j < numCols; j++) {
                //如果这个位置可用
                if (seatLayout[i][j] == 0) {
                    //连续座位标识
                    int consecutiveSeats = 0;
                    //往右遍历
                    for (int k = j; k < numCols; k++) {
                        //算上自己
                        if (seatLayout[i][k] == 0) {
                            //连续+1,其实默认就是1,因为可能传进来的numSeats就是1
                            consecutiveSeats++;
                            //如果找到了那么多个连续的
                            if (consecutiveSeats == numSeats) {
                                //然后倒序加入座位
                                for (int l = k - numSeats + 1; l <= k; l++) {
                                    selectedSeats.add(new int[]{i, l});
                                }
                                break;
                            }
                        } else {
                            //重置
                            consecutiveSeats = 0;
                        }
                    }
                    //如果不为空说明找到了连续的,break
                    if (!selectedSeats.isEmpty()) {
                        break;
                    }
                }
            }
            if (!selectedSeats.isEmpty()) {
                break;
            }
        }
        if (CollUtil.isEmpty(selectedSeats)) {
            return null;
        }
        //转化成真实的座位就好了
        int[][] actualSeat = new int[numSeats][2];
        int i = 0;
        for (int[] seat : selectedSeats) {
            int row = seat[0] + 1;
            int col = seat[1] + 1;
            actualSeat[i][0] = row;
            actualSeat[i][1] = col;
            i++;
        }
        return actualSeat;
    }

    public static int[][] nonAdjacent(int numSeats, int[][] seatLayout) {
        int numRows = seatLayout.length;
        int numCols = seatLayout[0].length;
        List<int[]> selectedSeats = new ArrayList<>();
        //不连续的只需要找到空闲座位就可以了
        for (int i = 0; i < numRows; i++) {
            for (int j = 0; j < numCols; j++) {
                if (seatLayout[i][j] == 0) {
                    selectedSeats.add(new int[]{i, j});
                    if (selectedSeats.size() == numSeats) {
                        break;
                    }
                }
            }
            if (selectedSeats.size() == numSeats) {
                break;
            }
        }
        return convertToActualSeat(selectedSeats);
    }

```

### 扣减余票缓存
1. 第一行代码就是abstractStrategyChoose.chooseAndExecuteResp(buildStrategyKey, selectSeatDTO)会调用到executeResp里面,然后不同策略模式里面重写selectSeats即可
1. 得到需要扣减的站点关系
2. 扣减余票缓存

```java
    private List<TrainPurchaseTicketRespDTO> distributeSeats(Integer trainType, Integer seatType, PurchaseTicketReqDTO requestParam, List<PurchaseTicketPassengerDetailDTO> passengerSeatDetails) {
        //构建出策略模式的mark标识,为交通工具名字+座位类型,如HIGH_SPEED_RAIN+BUSINESS_CLASS
        String buildStrategyKey = VehicleTypeEnum.findNameByCode(trainType) + VehicleSeatTypeEnum.findNameByCode(seatType);
        SelectSeatDTO selectSeatDTO = SelectSeatDTO.builder()
                .seatType(seatType)
                .passengerSeatDetails(passengerSeatDetails)
                .requestParam(requestParam)
                .build();
        try {
            return abstractStrategyChoose.chooseAndExecuteResp(buildStrategyKey, selectSeatDTO);
        } catch (ServiceException ex) {
            throw new ServiceException("当前车次列车类型暂未适配，请购买G35或G39车次");
        }
    }
```
```java
    public <REQUEST, RESPONSE> RESPONSE chooseAndExecuteResp(String mark, REQUEST requestParam) {
        AbstractExecuteStrategy executeStrategy = choose(mark, null);
        return (RESPONSE) executeStrategy.executeResp(requestParam);
    }
```
```java
    public List<TrainPurchaseTicketRespDTO> executeResp(SelectSeatDTO requestParam) {
        List<TrainPurchaseTicketRespDTO> actualResult = selectSeats(requestParam);
        // 扣减车厢余票缓存，扣减站点余票缓存
        if (CollUtil.isNotEmpty(actualResult) && !StrUtil.equals(ticketAvailabilityCacheUpdateType, "binlog")) {
            String trainId = requestParam.getRequestParam().getTrainId();
            String departure = requestParam.getRequestParam().getDeparture();
            String arrival = requestParam.getRequestParam().getArrival();
            StringRedisTemplate stringRedisTemplate = (StringRedisTemplate) distributedCache.getInstance();
            List<RouteDTO> routeDTOList = trainStationService.listTakeoutTrainStationRoute(trainId, departure, arrival);
            routeDTOList.forEach(each -> {
                String keySuffix = StrUtil.join("_", trainId, each.getStartStation(), each.getEndStation());
                stringRedisTemplate.opsForHash().increment(TRAIN_STATION_REMAINING_TICKET + keySuffix, String.valueOf(requestParam.getSeatType()), -actualResult.size());
            });
        }
        return actualResult;
    }
```

### 锁定沿途车站的车票
1. 获取到开始站点和结束站点中间所有需要锁定的路段
2. 这里的扣减逻辑是:出发站之前的每一个站点都要和(出发站+1~列车终点站)被扣减,(出发站~结束站-1)和自身之后的所有站点都需要扣减
3. 遍历每一张票,每一张票再遍历所有路段,进行锁定操作

北京南-南京南
![](https://quan-blog-1321822882.cos.ap-shanghai.myqcloud.com/2024/03/04/1709561597736.jpg)

济南西-杭州东
![](https://quan-blog-1321822882.cos.ap-shanghai.myqcloud.com/2024/03/04/1709561659288.jpg)


```java
    @Override
    public void lockSeat(String trainId, String departure, String arrival, List<TrainPurchaseTicketRespDTO> trainPurchaseTicketRespList) {
        //获取到开始站点和结束站点中间所有需要扣减库存的路段
        List<RouteDTO> routeList = trainStationService.listTakeoutTrainStationRoute(trainId, departure, arrival);
        //对于每一张票,都需要根据他们的开始站点和结束站点扣除所有的票
        trainPurchaseTicketRespList.forEach(each -> routeList.forEach(item -> {
            //更新语句,找到对应的座位
            LambdaUpdateWrapper<SeatDO> updateWrapper = Wrappers.lambdaUpdate(SeatDO.class)
                    .eq(SeatDO::getTrainId, trainId)
                    .eq(SeatDO::getCarriageNumber, each.getCarriageNumber())
                    .eq(SeatDO::getStartStation, item.getStartStation())
                    .eq(SeatDO::getEndStation, item.getEndStation())
                    .eq(SeatDO::getSeatNumber, each.getSeatNumber());
            //锁定这个座位,改变座位的状态
            SeatDO updateSeatDO = SeatDO.builder()
                    .seatStatus(SeatStatusEnum.LOCKED.getCode())
                    .build();
            seatMapper.update(updateSeatDO, updateWrapper);
        }));
    }

```

```java
    @Override
    public List<RouteDTO> listTakeoutTrainStationRoute(String trainId, String departure, String arrival) {
        LambdaQueryWrapper<TrainStationDO> queryWrapper = Wrappers.lambdaQuery(TrainStationDO.class)
                .eq(TrainStationDO::getTrainId, trainId)
                .select(TrainStationDO::getDeparture);
        List<TrainStationDO> trainStationDOList = trainStationMapper.selectList(queryWrapper);
        List<String> trainStationAllList = trainStationDOList.stream().map(TrainStationDO::getDeparture).collect(Collectors.toList());
        return StationCalculateUtil.takeoutStation(trainStationAllList, departure, arrival);
    }
```

```java
    /**
     * 计算出发站和终点站需要扣减余票的站点（包含出发站和终点站）
     *
     * @param stations     所有站点数据
     * @param startStation 出发站
     * @param endStation   终点站
     * @return 出发站和终点站需要扣减余票的站点（包含出发站和终点站）
     */
    public static List<RouteDTO> takeoutStation(List<String> stations, String startStation, String endStation) {
        List<RouteDTO> takeoutStationList = new ArrayList<>();
        int startIndex = stations.indexOf(startStation);
        int endIndex = stations.indexOf(endStation);
        if (startIndex == -1 || endIndex == -1 || startIndex >= endIndex) {
            return takeoutStationList;
        }
        //出发站之前的每一个站点都需要扣减出发站+1~列车终点站的票,因为中间票被买去了
        for (int i = 0; i < startIndex; i++) {
            for (int j = 1; j < stations.size() - startIndex; j++) {
                takeoutStationList.add(new RouteDTO(stations.get(i), stations.get(startIndex + j)));
            }
        }
        //出发点-结束点的站点都需要减去自身一直到结束的票
        for (int i = startIndex; i <= endIndex; i++) {
            for (int j = i + 1; j < stations.size() && i < endIndex; j++) {
                takeoutStationList.add(new RouteDTO(stations.get(i), stations.get(j)));
            }
        }
        return takeoutStationList;
    }

```




## ticket-service处理订单

1. 构建出ticketDo保存入数据库
2. 构建出orderDo和orderItemDoList
3. 远程调用订单服务创建订单

```java
        // 选择座位,返回座位号和金额以及乘车人的信息,并且锁定沿途的车票
        List<TrainPurchaseTicketRespDTO> trainPurchaseTicketResults = trainSeatTypeSelector.select(trainDO.getTrainType(), requestParam);
        //根据返回的买票结果构建出TicketDo的list
        List<TicketDO> ticketDOList = trainPurchaseTicketResults.stream()
                .map(each -> TicketDO.builder()
                        .username(UserContext.getUsername())
                        .trainId(Long.parseLong(requestParam.getTrainId()))
                        .carriageNumber(each.getCarriageNumber())
                        .seatNumber(each.getSeatNumber())
                        .passengerId(each.getPassengerId())
                        .ticketStatus(TicketStatusEnum.UNPAID.getCode())
                        .build())
                .toList();
        //保存进数据库
        saveBatch(ticketDOList);
        Result<String> ticketOrderResult;
        try {
            //创建订单的远程请求实体
            List<TicketOrderItemCreateRemoteReqDTO> orderItemCreateRemoteReqDTOList = new ArrayList<>();
            trainPurchaseTicketResults.forEach(each -> {
                //组装订单请求中的ticketOrderItems字段,比下面多一个phone
                TicketOrderItemCreateRemoteReqDTO orderItemCreateRemoteReqDTO = TicketOrderItemCreateRemoteReqDTO.builder()
                        .amount(each.getAmount())
                        .carriageNumber(each.getCarriageNumber())
                        .seatNumber(each.getSeatNumber())
                        .idCard(each.getIdCard())
                        .idType(each.getIdType())
                        .phone(each.getPhone())
                        .seatType(each.getSeatType())
                        .ticketType(each.getUserType())
                        .realName(each.getRealName())
                        .build();
                //组装好订单详细的返回信息
                TicketOrderDetailRespDTO ticketOrderDetailRespDTO = TicketOrderDetailRespDTO.builder()
                        .amount(each.getAmount())
                        .carriageNumber(each.getCarriageNumber())
                        .seatNumber(each.getSeatNumber())
                        .idCard(each.getIdCard())
                        .idType(each.getIdType())
                        .seatType(each.getSeatType())
                        .ticketType(each.getUserType())
                        .realName(each.getRealName())
                        .build();
                orderItemCreateRemoteReqDTOList.add(orderItemCreateRemoteReqDTO);
                ticketOrderDetailResults.add(ticketOrderDetailRespDTO);
            });
            //通过StationRelation表获取到出发时间和到达时间
            LambdaQueryWrapper<TrainStationRelationDO> queryWrapper = Wrappers.lambdaQuery(TrainStationRelationDO.class)
                    .eq(TrainStationRelationDO::getTrainId, trainId)
                    .eq(TrainStationRelationDO::getDeparture, requestParam.getDeparture())
                    .eq(TrainStationRelationDO::getArrival, requestParam.getArrival());
            TrainStationRelationDO trainStationRelationDO = trainStationRelationMapper.selectOne(queryWrapper);
            //组装出订单远程访问的请求对象
            TicketOrderCreateRemoteReqDTO orderCreateRemoteReqDTO = TicketOrderCreateRemoteReqDTO.builder()
                    .departure(requestParam.getDeparture())
                    .arrival(requestParam.getArrival())
                    .orderTime(new Date())
                    .source(SourceEnum.INTERNET.getCode())
                    .trainNumber(trainDO.getTrainNumber())
                    .departureTime(trainStationRelationDO.getDepartureTime())
                    .arrivalTime(trainStationRelationDO.getArrivalTime())
                    //乘车日期
                    .ridingDate(trainStationRelationDO.getDepartureTime())
                    .userId(UserContext.getUserId())
                    .username(UserContext.getUsername())
                    .trainId(Long.parseLong(requestParam.getTrainId()))
                    .ticketOrderItems(orderItemCreateRemoteReqDTOList)
                    .build();
            //调用创建订单远程服务
            ticketOrderResult = ticketOrderRemoteService.createTicketOrder(orderCreateRemoteReqDTO);
            if (!ticketOrderResult.isSuccess() || StrUtil.isBlank(ticketOrderResult.getData())) {
                log.error("订单服务调用失败，返回结果：{}", ticketOrderResult.getMessage());
                throw new ServiceException("订单服务调用失败");
            }
        } catch (Throwable ex) {
            log.error("远程调用订单服务创建错误，请求参数：{}", JSON.toJSONString(requestParam), ex);
            throw ex;
        }
        //返回订单号和订单详情列表
        return new TicketPurchaseRespDTO(ticketOrderResult.getData(), ticketOrderDetailResults);
```

## order-service创建订单
1. 生成一个订单号
2. 构建订单参数,将订单插入订单表中,再构建每一个order_item,批处理插入
3. 发送RocketMQ延时消息,指定时间后取消订单

```java
    @Transactional(rollbackFor = Exception.class)
    @Override
    public String createTicketOrder(TicketOrderCreateReqDTO requestParam) {
        //通过基因法将用户 ID 融入到订单号,获取到订单号
        String orderSn = OrderIdGeneratorManager.generateId(requestParam.getUserId());
        //构建订单参数
        OrderDO orderDO = OrderDO.builder().orderSn(orderSn)
                .orderTime(requestParam.getOrderTime())
                .departure(requestParam.getDeparture())
                .departureTime(requestParam.getDepartureTime())
                .ridingDate(requestParam.getRidingDate())
                .arrivalTime(requestParam.getArrivalTime())
                .trainNumber(requestParam.getTrainNumber())
                .arrival(requestParam.getArrival())
                .trainId(requestParam.getTrainId())
                .source(requestParam.getSource())
                .status(OrderStatusEnum.PENDING_PAYMENT.getStatus())
                .username(requestParam.getUsername())
                .userId(String.valueOf(requestParam.getUserId()))
                .build();
        //将订单插入订单表中
        orderMapper.insert(orderDO);
        //获取订单中的items,也就是每一张票的订单
        List<TicketOrderItemCreateReqDTO> ticketOrderItems = requestParam.getTicketOrderItems();
        List<OrderItemDO> orderItemDOList = new ArrayList<>();
        List<OrderItemPassengerDO> orderPassengerRelationDOList = new ArrayList<>();
        ticketOrderItems.forEach(each -> {
            //构建出每一个order item
            OrderItemDO orderItemDO = OrderItemDO.builder()
                    .trainId(requestParam.getTrainId())
                    .seatNumber(each.getSeatNumber())
                    .carriageNumber(each.getCarriageNumber())
                    .realName(each.getRealName())
                    .orderSn(orderSn)
                    .phone(each.getPhone())
                    .seatType(each.getSeatType())
                    .username(requestParam.getUsername()).amount(each.getAmount()).carriageNumber(each.getCarriageNumber())
                    .idCard(each.getIdCard())
                    .ticketType(each.getTicketType())
                    .idType(each.getIdType())
                    .userId(String.valueOf(requestParam.getUserId()))
                    .status(0)
                    .build();
            orderItemDOList.add(orderItemDO);
            //构建出证件号和订单号的映射
            OrderItemPassengerDO orderPassengerRelationDO = OrderItemPassengerDO.builder()
                    .idType(each.getIdType())
                    .idCard(each.getIdCard())
                    .orderSn(orderSn)
                    .build();
            orderPassengerRelationDOList.add(orderPassengerRelationDO);
        });
        //批处理加入
        orderItemService.saveBatch(orderItemDOList);
        orderPassengerRelationService.saveBatch(orderPassengerRelationDOList);
        try {
            // 发送 RocketMQ 延时消息，指定时间后取消订单
            DelayCloseOrderEvent delayCloseOrderEvent = DelayCloseOrderEvent.builder()
                    .trainId(String.valueOf(requestParam.getTrainId()))
                    .departure(requestParam.getDeparture())
                    .arrival(requestParam.getArrival())
                    .orderSn(orderSn)
                    .trainPurchaseTicketResults(requestParam.getTicketOrderItems())
                    .build();
            SendResult sendResult = delayCloseOrderSendProduce.sendMessage(delayCloseOrderEvent);
            if (!Objects.equals(sendResult.getSendStatus(), SendStatus.SEND_OK)) {
                throw new ServiceException("投递延迟关闭订单消息队列失败");
            }
        } catch (Throwable ex) {
            log.error("延迟关闭订单消息队列发送错误，请求参数：{}", JSON.toJSONString(requestParam), ex);
            throw ex;
        }
        return orderSn;
    }
```

## ticket-service处理订单延时关闭消息
1. 远程调用订单模块关闭订单
2. 成功关闭订单之后,根据上面的算法将两个站点需要解锁的票解锁
3. 更新站点余票,先把票按照座位类型来分类,遍历每一种票,再遍历每一段需要解锁的票的站,找到票的缓存的key=prefix+trainId+出发站+结束站,hash第二层为seatType,增加对应乘车人数量的票
4. todo 回滚列车令牌

```java
    @Override
    public void onMessage(MessageWrapper<DelayCloseOrderEvent> delayCloseOrderEventMessageWrapper) {
        log.info("[延迟关闭订单] 开始消费：{}", JSON.toJSONString(delayCloseOrderEventMessageWrapper));
        //获取到携带的消息
        DelayCloseOrderEvent delayCloseOrderEvent = delayCloseOrderEventMessageWrapper.getMessage();
        //获取到订单号
        String orderSn = delayCloseOrderEvent.getOrderSn();
        Result<Boolean> closedTickOrder;
        try {
            //调用订单模块关闭订单
            closedTickOrder = ticketOrderRemoteService.closeTickOrder(new CancelTicketOrderReqDTO(orderSn));
        } catch (Throwable ex) {
            log.error("[延迟关闭订单] 订单号：{} 远程调用订单服务失败", orderSn, ex);
            throw ex;
        }
        //如果成功关闭,那么需要更新余票缓存
        if (closedTickOrder.isSuccess() && !StrUtil.equals(ticketAvailabilityCacheUpdateType, "binlog")) {
            //如果用户已经支付了那么直接返回就好了
            if (!closedTickOrder.getData()) {
                log.info("[延迟关闭订单] 订单号：{} 用户已支付订单", orderSn);
                return;
            }
            String trainId = delayCloseOrderEvent.getTrainId();
            String departure = delayCloseOrderEvent.getDeparture();
            String arrival = delayCloseOrderEvent.getArrival();
            List<TrainPurchaseTicketRespDTO> trainPurchaseTicketResults = delayCloseOrderEvent.getTrainPurchaseTicketResults();
            try {
                //将两个站点中间的那些站点的票解锁,因为在购买的时候我们锁定了那些票导致不可用
                seatService.unlock(trainId, departure, arrival, trainPurchaseTicketResults);
            } catch (Throwable ex) {
                log.error("[延迟关闭订单] 订单号：{} 回滚列车DB座位状态失败", orderSn, ex);
                throw ex;
            }
            try {
                StringRedisTemplate stringRedisTemplate = (StringRedisTemplate) distributedCache.getInstance();
                //将座位类型来分类
                Map<Integer, List<TrainPurchaseTicketRespDTO>> seatTypeMap = trainPurchaseTicketResults.stream()
                        .collect(Collectors.groupingBy(TrainPurchaseTicketRespDTO::getSeatType));
                //获取需列车站点扣减路线关系,获取开始站点和目的站点、中间站点以及关联站点信息
                List<RouteDTO> routeDTOList = trainStationService.listTakeoutTrainStationRoute(trainId, departure, arrival);
                routeDTOList.forEach(each -> {
                    //找到票的缓存的key
                    String keySuffix = StrUtil.join("_", trainId, each.getStartStation(), each.getEndStation());
                    seatTypeMap.forEach((seatType, trainPurchaseTicketRespDTOList) -> {
                        //增加缓存,增加的数量就是这个座位类型有多少张票
                        stringRedisTemplate.opsForHash()
                                .increment(TRAIN_STATION_REMAINING_TICKET + keySuffix, String.valueOf(seatType), trainPurchaseTicketRespDTOList.size());
                    });
                });
                //todo 注释
                TicketOrderDetailRespDTO ticketOrderDetail = BeanUtil.convert(delayCloseOrderEvent, TicketOrderDetailRespDTO.class);
                ticketOrderDetail.setPassengerDetails(BeanUtil.convert(delayCloseOrderEvent.getTrainPurchaseTicketResults(), TicketOrderPassengerDetailRespDTO.class));
                ticketAvailabilityTokenBucket.rollbackInBucket(ticketOrderDetail);
            } catch (Throwable ex) {
                log.error("[延迟关闭订单] 订单号：{} 回滚列车Cache余票失败", orderSn, ex);
                throw ex;
            }
        }
    }
```

```java
    @Override
    public void unlock(String trainId, String departure, String arrival, List<TrainPurchaseTicketRespDTO> trainPurchaseTicketResults) {
        List<RouteDTO> routeList = trainStationService.listTakeoutTrainStationRoute(trainId, departure, arrival);
        trainPurchaseTicketResults.forEach(each -> routeList.forEach(item -> {
            LambdaUpdateWrapper<SeatDO> updateWrapper = Wrappers.lambdaUpdate(SeatDO.class)
                    .eq(SeatDO::getTrainId, trainId)
                    .eq(SeatDO::getCarriageNumber, each.getCarriageNumber())
                    .eq(SeatDO::getStartStation, item.getStartStation())
                    .eq(SeatDO::getEndStation, item.getEndStation())
                    .eq(SeatDO::getSeatNumber, each.getSeatNumber());
            SeatDO updateSeatDO = SeatDO.builder()
                    .seatStatus(SeatStatusEnum.AVAILABLE.getCode())
                    .build();
            seatMapper.update(updateSeatDO, updateWrapper);
        }));
    }
```

