
## JVM内存结构

JVM 大致可以划分为三个部分：类加载器、运行时数据区和执行引擎。

![[Attachments/Pasted image 20240412155234.png]]

**类加载器** : 负责从文件系统、网络或其他来源加载 Class 文件，将 Class 文件中的二进制数据读入到内存当中。
**运行时数据区** : JVM 在执行 Java 程序时，需要在内存中分配空间来处理各种数据，这些内存区域主要包括方法区、堆、栈、程序计数器和本地方法栈。
**执行引擎** : 执行引擎是 JVM 的心脏，负责执行字节码。它包括一个虚拟处理器，还包括即时编译器（JIT Compiler）和垃圾回收器（Garbage Collector）。

## 运行时数据区

![[Attachments/Pasted image 20240917135336.png]]

JVM的内存结构主要分为以下几个部分：

- **元空间**：元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是**使用本地内存**。
- **Java 虚拟机栈**：每个线程有一个私有的栈，随着线程的创建而创建。栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了**局部变量表**（基本数据类型和对象引用）、**操作数栈**、**方法出口**  等信息。栈的大小可以固定也可以动态扩展。
- **本地方法栈**：与虚拟机栈类似，区别是虚拟机栈执行java方法，本地方法站执行native方法。在虚拟机规范中对本地方法栈中方法使用的语言、使用方法与数据结构没有强制规定，因此虚拟机可以自由实现它。
- **程序计数器**：程序计数器可以看成是当前线程所执行的字节码的行号指示器。在任何一个确定的时刻，一个处理器（对于多内核来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要一个独立的程序计数器，我们称这类内存区域为“线程私有”内存。
- **堆内存**：堆内存是 JVM 所有线程共享的部分，在虚拟机启动的时候就已经创建。所有的对象和数组都在堆上进行分配。这部分空间可通过 GC 进行回收。当申请不到空间时会抛出 OutOfMemoryError。堆是JVM内存占用最大，管理最复杂的一个区域。其唯一的用途就是存放对象实例：所有的对象实例及数组都在对上进行分配。**jdk1.8后，字符串常量池从永久代(方法区)中剥离出来，存放在堆中**。
- **直接内存**：直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中农定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一种基于通道(Channel)与缓冲区（Buffer）的I/O 方式，它可以使用native 函数库直接分配堆外内存，然后通脱一个存储在Java堆中的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为**避免了在Java堆和Native堆中来回复制数据**。

## 堆和栈的区别

- **用途**：栈主要用于存储局部变量、方法调用的参数、方法返回地址以及一些临时数据。堆用于存储对象的实例（包括类的实例和数组）
- **生命周期**：栈中的数据具有确定的生命周期，当一个方法调用结束时，其对应的栈帧就会被销毁，栈中存储的局部变量也会随之消失。堆中的对象生命周期不确定，对象会在垃圾回收机制（Garbage Collection, GC）检测到对象不再被引用时才被回收。
- **存取速度**：栈的存取速度通常比堆快，因为栈遵循先进后出（LIFO, Last In First Out）的原则，操作简单快速。堆的存取速度相对较慢，因为对象在堆上的分配和回收需要更多的时间，而且垃圾回收机制的运行也会影响性能。
- **存储空间**：栈的空间相对较小，且固定，由操作系统管理。当栈溢出时，通常是因为递归过深或局部变量过大。堆的空间较大，动态扩展，由JVM管理。堆溢出通常是由于创建了太多的大对象或未能及时回收不再使用的对象。
- **可见性**：栈中的数据对线程是私有的，每个线程有自己的栈空间。堆中的数据对线程是共享的，所有线程都可以访问堆上的对象。

## 堆

![[Attachments/Pasted image 20240917141448.png]]

- **新生代（Young Generation）**:新生代分为Eden Space和Survivor Space。在Eden Space中， 大多数新创建的对象首先存放在这里。Eden区相对较小，当Eden区满时，会触发一次Minor GC（新生代垃圾回收）。在Survivor Spaces中，通常分为两个相等大小的区域，称为S0（Survivor 0）和S1（Survivor 1）。在每次Minor GC后，存活下来的对象会被移动到其中一个Survivor空间，以继续它们的生命周期。这两个区域轮流充当对象的中转站，帮助区分短暂存活的对象和长期存活的对象。
- **老年代（Old Generation/Tenured Generation）**:存放过一次或多次Minor GC仍存活的对象会被移动到老年代。老年代中的对象生命周期较长，因此Major GC（也称为Full GC，涉及老年代的垃圾回收）发生的频率相对较低，但其执行时间通常比Minor GC长。老年代的空间通常比新生代大，以存储更多的长期存活对象。
- **大对象区（Large Object Space / Humongous Objects）**:在某些JVM实现中（如G1垃圾收集器），为大对象分配了专门的区域，称为大对象区或Humongous Objects区域。大对象是指需要大量连续内存空间的对象，如大数组。这类对象直接分配在老年代，以避免因频繁的年轻代晋升而导致的内存碎片化问题。

## 方法区

《深入理解Java虚拟机》书中对方法区（Method Area）存储内容描述如下：它用于存储已被虚拟机加载的**类型信息、常量、静态变量、即时编译器编译后的代码缓存**等。

- 类信息：包括类的结构信息、类的访问修饰符、父类与接口等信息。
- 常量池：存储类和接口中的常量，包括字面值常量、符号引用，以及运行时常量池。
- 方法字节码：存储类的方法字节码，即编译后的代码。
- 符号引用：存储类和方法的符号引用，是一种直接引用不同于直接引用的引用类型。
- 运行时常量池：存储着在类文件中的常量池数据，在类加载后在方法区生成该运行时常量池。
- 常量池缓存：用于提升类加载的效率，将常用的常量缓存起来方便使用


![](Attachments/Images/Pasted%20image%2020240321102432.png)

![](Attachments/Images/Pasted%20image%2020240321102437.png)

---


## 运行时常量池

运行时常量池在方法区中

Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 **常量池表(Constant Pool Table)** 。

字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。

常量池表会在类加载后存放到方法区的运行时常量池中。

运行时常量池的功能类似于传统编程语言的符号表，尽管它包含了比典型符号表更广泛的数据。

既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 `OutOfMemoryError` 错误

## 为什么要将永久代替换为元空间呢?

1、整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。

>当元空间溢出时会得到如下错误：`java.lang.OutOfMemoryError: MetaSpace`

2、元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 `MaxPermSize` 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。

3、在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。

## OOP-Klass

这里的 OOP 指的是 Ordinary Object Pointer （普通对象指针），它用来表示对象的实例信息，看起来像个指针，实际上是藏在指针里的对象（是一个指针，作为一个java对象头存在）
Klass 则包含元数据和方法信息，用来描述Java类，是“类元信息”
之所以采用这个模型是因为HotSopt JVM的设计者**不想让每个对象中都含有一个vtable（虚方法表）**，所以就把对象模型拆成klass和oop，其中oop中不含有任何虚方法，而Klass就含有虚函数表，可以进行method dispatch

---

**instanceOopDesc**主要包含markOop \_mark和union_metadata，实例数据则保存在oopDesc中定义的各种field中。

1.Mark Word：用于存储对象的运行时记录信息，如哈希值、GC 分代年龄(Age)、锁状态标志（偏向锁、轻量级锁、重量级锁）、线程持有的锁、偏向线程 ID、偏向时间戳等。
2.元数据指针：OopDesc 中的 \_metadata 成员，它是联合体，可以表示未压缩的 Klass 指针(\_klass)和压缩的 Klass 指针（narrowOop）。对应的 klass 指针指向一个存储类的元数据的 Klass 对象。

---

Klass（**InstanceKlass**） 与 Class 对象有什么关系？

在 HotSpot VM 里，java.lang.Class 的实例被称为“Java mirror”，意思是它是 JVM 内部用的 klass 对象的“镜像”；作用是把 InstanceKlass 对象包装了一层来暴露给 Java 层(开发者)使用，但**主要用途是提供反射访问**；创建时机是加载->连接->初始化 的初始化阶段。

每个 **Java 对象的对象头**里，\_klass 字段会指向一个JVM内部用来记录类的元数据用的 InstanceKlass 对象 , **insanceKlass里有个 \_java_mirror 字段**（见下图），**指向该类所对应的Java镜像**——java.lang.Class实例

另外，HotSpot VM会给 **Class 对象注入一个隐藏字段“klass”**，用于**指回到其对应的 InstanceKlass** 对象。这样，klass与mirror之间就有双向引用(很有意思的点)，可以来回导航

当我们写 obj.getClass()，在 HotSpot VM 里实际上经过了两层间接引用才能找到最终的 Class 对象

---

JVM 在加载 class 时，会创建 instanceKlass，用来在JVM层表示该Java类，包括常量池、字段、方法等，存放在方法区；
我们在Java代码中 new 一个对象时，JVM会创建一个instanceOopDesc实例来表示这个对象，存放在堆区，其引用，存放在栈区；这个对象中包含了两部分信息，对象头和元数据。对象头有一些运行时的数据，其中就包括跟多线程相关的锁的信息。元数据维护的是指针，指向的是对象所属的类的instanceKlass。
HotSpot 并不把 instanceKlass 暴露给 Java，而会另外创建对应的 instanceOopDesc 来表示 java.lang.Class 对象，并将后者称为前者的“Java镜像”，klass 持有指向 oop 引用(\_java_mirror 便是该 instanceKlass对Class对象的引用)；

![[Attachments/Pasted image 20240917171233.png]]

JDK6及以前，静态变量放在InstanceKlass对象的末尾；JDK7及以后，变到了Class对象，也就是mirror对象的末尾 , 所以之前静态变量在方法区 , 后面在堆的Class对象里面


## 字符串常量池

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建

```java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true
```

HotSpot 虚拟机中字符串常量池可以简单理解为一个固定大小的`HashTable` ，容量为 `StringTableSize`，保存的是字符串（key）和 字符串对象的引用（value）的映射关系，字符串对象的引用指向堆中的字符串对象。

JDK1.7 之前，字符串常量池存放在永久代。JDK1.7 字符串常量池和静态变量从永久代移动了 Java 堆中。

**为什么要把字符串常量池移动到堆**

主要是因为永久代（方法区实现）的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。


## new一个对象的过程

![[Attachments/Pasted image 20240918144955.png]]

1. **类加载检查**：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在**常量池**中定位到一个类的**符号引用**，并且检查这个符号引用代表的类是否已被**加载过、解析和初始化**过。如果没有，那必须先执行相应的**类加载过程**。
2. **分配内存**：在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的**内存大小**在**类加载**完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
3. **初始化零值**：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
4. **进行必要设置，比如对象头**：初始化零值完成之后，虚拟机要对对象进行**必要的设置**，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。这些信息存放在**对象头**中。另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
5. **执行 init 方法**：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始——构造函数，即class文件中的方法还没有执行，所有的字段都还为零，**对象需要的其他资源和状态信息**还没有按照预定的意图构造好。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全被构造出来。

## 对象的内存布局

在 HotSpot 中，对象在堆内存中的存储布局可以划分为三个部分：对象头（Object Header）、实例数据（Instance Data）和对齐填充（Padding）。

![[Attachments/Pasted image 20240412173648.png]]

**对象头**是每个对象都有的，包含三部分主要信息：

- **标记字**（Mark Word）：包含了对象自身的运行时数据，如哈希码（HashCode）、垃圾回收分代年龄、锁状态标志、线程持有的锁、偏向线程 ID 等信息。在 64 位操作系统下占 8 个字节，32 位操作系统下占 4 个字节。
- **类型指针**（Class Pointer）：指向对象所属类的元数据的指针，JVM 通过这个指针来确定对象的类。在开启了压缩指针的情况下，这个指针可以被压缩。在开启指针压缩的情况下占 4 个字节，否则占 8 个字节。
- **数组长度**（Array Length）：如果对象是数组类型，还会有一个额外的数组长度字段。占 4 个字节。

**实例数据**存储了对象的具体信息，即在类中定义的各种字段数据（不包括由父类继承的字段）。这部分的大小取决于对象的属性和它们的类型（如 int、long、引用类型等）。JVM 会对这些数据进行对齐，以确保高效的访问速度。

**对齐填充**，为了使对象的总大小是 8 字节的倍数（这在大多数现代计算机体系结构中是最优访问边界），JVM 可能会在对象末尾添加一些填充。这部分是为了满足内存对齐的需求，并不包含任何具体的数据。

## 一个Object对象的大小

一般来说，对象的大小是由对象头、实例数据和对齐填充三个部分组成的。

- 对象头的大小在 32 位 JVM 上是 8 字节，在 64 位 JVM 上是 16 字节（如果开启了压缩指针，就是 12 字节）。
- 实例数据的大小取决于对象的属性和它们的类型。对于`new Object()`来说，Object 类本身没有实例字段，因此这部分可能非常小或者为零。
- 对齐填充的大小取决于对象头和实例数据的大小，以确保对象的总大小是 8 字节的倍数。

一般来说，目前的操作系统都是 64 位的，并且 JDK 8 中的压缩指针是默认开启的，因此在 64 位 JVM 上，`new Object()`的大小是 16 字节（12 字节的对象头 + 4 字节的对齐填充）。

## 什么是指针碰撞和空闲列表

内存分配有两种方式，**指针碰撞**（Bump The Pointer）、**空闲列表**（Free List）。

![[Attachments/Pasted image 20240412172407.png]]

- 指针碰撞：假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”。
- 空闲列表：如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。
- 两种方式的选择由 Java 堆是否规整决定，Java 堆是否规整是由选择的垃圾收集器是否具有压缩整理能力决定的

## JVM里面new对象 , 会线程不安全吗

会，假设 JVM 虚拟机上，每一次 new 对象时，指针就会向右移动一个对象 size 的距离，一个线程正在给 A 对象分配内存，指针还没有来的及修改，另一个为 B 对象分配内存的线程，又引用了这个指针来分配内存，这就发生了抢占。

有两种可选方案来解决这个问题：

![[Attachments/Pasted image 20240412173449.png]]

- 采用 CAS 分配重试的方式来保证更新操作的原子性
- 每个线程在 Java 堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。

## 对象的访问定位

使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改
使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。HotSpot 虚拟机主要使用的就是这种方式来进行对象访问

**句柄**

如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息

![](Attachments/Images/Pasted%20image%2020240321104050.png)

---

**直接指针**

如果使用直接指针访问，reference 中存储的直接就是对象的地址。

![](Attachments/Images/Pasted%20image%2020240321104127.png)


## 判断垃圾的方法

**引用计数法** : 给对象中添加一个引用计数器 , 这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间循环引用的问题

**可达性分析算法** :

这个算法的基本思想就是通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

---

**哪些对象可以作为gc roots**

- 虚拟机栈中的引用（方法的参数、局部变量等）
- 本地方法栈中的引用
- 类静态变量
- 运行时常量池中的常量（String 或 Class 类型）

**对象可以被回收就一定会被回收吗**

可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 `finalize` 方法。当对象没有覆盖 `finalize` 方法，或 `finalize` 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

## 垃圾回收算法

### 标记清除算法

标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：

1. **效率问题**：标记和清除两个过程效率都不高。
2. **空间问题**：标记清除后会产生大量不连续的内存碎片

适合老年代 , 因为需要清除的对象较少

### 复制算法

为了解决标记-清除算法的效率和内存碎片问题，复制（Copying）收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收

虽然改进了标记-清除算法，但依然存在下面这些问题：

- **可用内存变小**：可用内存缩小为原来的一半。
- **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差

适合新生代 , 因为新生代存活对象少

### 标记整理算法

标记-整理（Mark-and-Compact）算法是根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。

由于多了整理这一步，因此效率也不高，适合老年代这种垃圾回收频率不是很高的场景

### 分代回收算法

分代收集是将内存划分成了新生代和老年代。分配的依据是对象的生存周期，或者说经历过的 GC 次数。对象创建时，一般在新生代申请内存，当经历一次 GC 之后如果对还存活，那么对象的年龄 +1。当年龄超过一定值(默认是 15，可以通过参数 -XX:MaxTenuringThreshold 来设定)后，如果对象还存活，那么该对象会进入老年代。

## 垃圾收集器

- JDK 8：Parallel Scavenge（新生代）+ Parallel Old（老年代）
- JDK 9 ~ JDK21: G1

![[Attachments/Pasted image 20240918172613.png]]


![[Attachments/Pasted image 20240413001207.png]]

### CMS收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

从名字中的**Mark Sweep**这两个词可以看出，CMS 收集器是一种 **“标记-清除”** 算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
- **并发清除：** 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![](Attachments/Images/Pasted%20image%2020240321114028.png)
从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- 存在内存碎片：由于CMS采用**标记清除算法**，在垃圾回收之后会**产生大量的内存碎片**。CMS虽然会在经历几次标记清除算法后进行碎片整理，但整理时会暂停用户线程。
- 存在浮动垃圾：CMS垃圾回收器在并发标记和并发清理阶段**由于用户线程并未停止**，该阶段可能会**产生浮动垃圾**，无法在本次被回收，只能等到下一次垃圾回收
- 退化问题：当老年代内存不足以分配对象时，CMS会退化为Serial Old单线程串行进行垃圾回收，导致性能下降
- 线程资源争抢：在并发标记和并发清理阶段，执行垃圾回收的线程数量由系统计算出，如果CPU核数有限，会**影响用户线程的执行性能**，导致程序变慢

### G1收集器

![[Attachments/Pasted image 20240918214748.png]]

G1 收集器的运作大致分为以下几个步骤(Mixed GC)：

- **初始标记**（initial mark），标记了从 GC Root 开始直接关联可达的对象。STW（Stop the World）执行。
- **并发标记**（concurrent marking），和用户线程并发执行，从 GC Root 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象、
- **最终标记**（Remark），STW，标记再并发标记过程中产生的垃圾。
- **筛选回收**（Live Data Counting And Evacuation），制定回收计划，选择多个 Region 构成回收集，把回收集中 Region 的存活对象复制到空的 Region 中，再清理掉整个旧 Region 的全部空间。需要 STW。


![](Attachments/Images/Pasted%20image%2020240321114211.png)

---

### 三色标记法

**初始标记阶段**

G1垃圾回收器在初始标记阶段采用**三色标记算法**标识对象

白色（垃圾对象）：白色代表该对象**不在GC Root的引用链**上，在标记开始时，堆内存中的所有对象默认都是白色，当标记结束，如果对象仍然为白色，则被认为是垃圾对象
灰色（待处理对象）：灰色代表该对象**在GC Root的引用链上**，但该对象所有引用的对象**还未被标记**过，是一个过渡颜色，最终会被标记为黑色
黑色（存活对象）：黑色代表该对象**在GC Root的引用链上**，且该对象所有引用的对象均**已被标记**过，代表存活对象

![[Attachments/Pasted image 20240918215930.png]]

实际上，标记对象的颜色其实是通过**位图**（**bitmap**）实现的，默认的白色对象的`bit`为`0`，黑色对象的`bit`位会被设置为`1`，而灰色对象不会体现在位图，会被放置于一个单独的队列，等待后续处理

---

**并发标记阶段**

从GC Root直接关联的对象进行完整遍历，标记出所有存活的对象，耗时较长，但本阶段与用户线程可同时并发执行，不会暂停用户线程。

在本阶段G1垃圾回收器会从灰色队列中获取到未标记完成的灰色对象，标记其引用关联的所有下一级对象（结束后自身会被标记为黑色），将其引用的下一级对象标记为灰色，放入灰色队列，重复这一过程，直到队列为空

但是，并发标记阶段由于用户线程并没有暂停，会产生新问题，即用户线程若在此期间修改了对象的引用关系，就会导致标记结果不准确，这里其实会误判两种情况：多标和漏标

**多标**：即本应该被回收的垃圾对象，却被标记为黑色存活对象。当已被标记的黑色对象或灰色对象，其引用被删除，就会造成多标
**漏标**：即本应该被标记为黑色的存活对象，却没有被正常标记为黑色，被垃圾回收。当未处理完的灰色对象断开了它引用的白色对象，且已处理完的黑色对象重新引用了该白色对象，则该白色对象会被漏标 , 本应该使用的对象还是白色的 , 会被清除

### SATB（G1解决并发标记）

Snapshot At The Beginning

多标的问题其实并不严重，顶多产生浮动垃圾，等到下一次垃圾回收时也会被回收，但漏标却是很致命的，已经影响到了程序的正常运行，而G1垃圾回收器采用了SATB原始快照技术解决了这一漏标问题

SATB主要为解决并发标记阶段可能产生的对象引用变化问题，SATB即一个原始快照，类似于拍照一样，记录某一时刻所有的对象，SATB的主要执行逻辑如下：

在标记开始时，创建一个**原始快照，记录当前所有存活的对象**
在标记执行过程中，**新创建的对象，直接标记为黑色**
在标记执行过程中，出现对象引用赋值操作，G1垃圾回收器采用写前屏障技术，将**引用的对象放入一个待处理的SATB队列**，该队列是每个线程独有的，最终会汇总到全局的SATB队列(防止并发问题)

![[Attachments/Pasted image 20240918231933.png]]

**最终标记阶段**

最终标记阶段会暂停用户线程，主要用于修正并发标记期间产生变动的对象，总体耗时短于并发标记阶段。

最终标记阶段首先会暂停用户线程，将所有线程的SATB队列合并到全局SATB队列，逐一消费。
在全局SATB队列中的对象，默认按照黑色存活对象处理，同时处理它们引用的其它对象。

**缺点**：显而易见，SATB也会造成多标的情况，将可以被回收的垃圾对象标记为存活对象，产生了浮动垃圾，这些浮动垃圾需要等到下一轮垃圾回收时被回收。

---

**筛选回收**

**区域选择**：G1垃圾回收器会针对各个Region的**回收价值进行排序**，评估最大暂停时间，选择特定的Region进行回收（一般是垃圾对象最多的区域）
**对象复制转移**：选定好Region后，首先会将GC Root根对象直接关联的对象转移到新的Region区域，然后依次转移其引用的对象
**更新引用关系**：对象转移到新的Region区域后，会清理到之前的Region。若其它Region区域中的对象引用了转移后的对象，则会重新设置它们的引用关系，避免对象移动位置后引用出错

### 增量更新（CMS解决并发标记）

![[Attachments/Pasted image 20240919092857.png]]

### 记忆集 , 卡表 , 写屏障

G1垃圾回收器年轻代回收时，采用了三种关键技术，分别是记忆集、卡表和写屏障。接下来我们层层递进，研究一下这些技术分别解决了什么问题。

当G1触发Young GC时，只会扫描年轻代区域（Eden区 + Survivor区）的对象，从GC Root根对象出发时，很容易扫描出年轻代的对象以及年轻代对象引用的其它年轻代的对象。

但这样会产生一个问题，如果年轻代的对象被老年代的对象引用了，应该如何识别出来呢？

---

**记忆集**

其实G1垃圾回收器内部维护了一种引用详情表，称为记忆集的数据结构，记录跨代引用，即非回收区域（老年代）对象引用回收区域（年轻代）对象的关系。

记忆集仅记录跨代的对象引用关系，不会记录年轻代区域之间的对象引用

在Young GC回收年轻代对象时，会将记忆集中的对象也加入到GC Root中，有效避免年轻代的对象被错误的回收

---

**卡表（Card Table）与卡页（Card Page）**

在G1垃圾回收器中，为了进一步压缩记忆集占用的内存，其将所有的`Region`区域按大小划分为多个分块，称为**卡页（Card Page）**，对每个卡页进行编号

![[Attachments/Pasted image 20240919000004.png]]

同时每个Region区域都会有额外配备一小块内存，这块内存称为卡表（Card Table），用于记录整个堆空间中有哪些卡页引用了自己Region区域的对象，卡表的底层数据结构是字节数组，每一个字节对应一个卡页，当某个卡页中的对象引用自己Region区域的对象时，会将卡表对应编号位置的字节修改为1，为1的字节被称之为脏卡

![[Attachments/Pasted image 20240919000025.png]]

此时生成记忆集就会比较容易，只用遍历各个`Region`的卡表，找到所有字节为`1`的脏卡，形成记忆集。

当年轻代垃圾回收标记存活对象时，G1将此记忆集中的所有对象也加入到`GC Root`根对象集合中，确保被老年代引用的年轻代对象标记为存活。

---
**写屏障（Write Barrier）**

更新卡表状态的底层采用了**写屏障**技术（具体为写后屏障），当执行对象引用相关的代码时，会在其代码前后插入对应的指令

写屏障类似与之前学过的`AOP`，会在引用对象赋值前后做一些额外的动作，主要分为两个：

- **写前屏障**：引用对象赋值前的特殊处理
- **写后屏障**：引用对象赋值后的特殊处理

JVM中的写屏障要与并发乱序执行中的内存屏障不一样，这里要区分它们

写后屏障指令判断到老年代对象引用年轻代对象时，会更改卡表中对应的字节为脏卡，同时会将脏卡放入到一个**脏卡队列**中，**JVM会通过单独的线程，定期读取脏卡队列中的数据，更新记忆集**

![[Attachments/Pasted image 20240919090323.png]]

可能会有小伙伴会产生好奇，在更新完卡表之后，为何不直接把脏卡写入记忆集呢？

这是由于写屏障指令是由用户线程完成的，如果有大量的用户线程修改对象引用关系，会产生线程安全问题，则需要对记忆集进行加锁，加锁之后势必会影响执行效率。

因此这里将脏卡先放入脏卡队列，采用单独的线程异步消费，避免影响用户线程

### ZGC收集器

与CMS中的ParNew和G1类似，ZGC也采用标记-复制算法，不过ZGC对该算法做了重大改进：ZGC在标记、转移和重定位阶段几乎都是并发的，这是ZGC实现停顿时间小于10ms目标的最关键原因

![[Attachments/Pasted image 20240919102636.png]]

![[Attachments/Pasted image 20240919102016.png]]

通过这四个标志位，JVM 可以从指针上直接看到对象的三色标记状态（Marked0、Marked1）、是否进入了重分配集（Remapped）、是否需要通过 finalize 方法来访问到（Finalizable）。

无需进行对象访问就可以获得 GC 信息，这大大提高了 GC 效率。

ZGC 使用**内存多重映射技术**，把物理内存映射为 Marked0、Marked1 和 Remapped 三个地址视图，利用地址视图的切换，ZGC 实现了高效的并发收集。

![[Attachments/Pasted image 20240919102141.png]]

**并发标记过程**中，GC 线程和 Java 应用线程会并行运行。这个过程需要注意下面几点：

- GC 标记线程访问对象时，如果对象地址视图是 Remapped，就把对象地址视图切换到 Marked0，如果对象地址视图已经是 Marked0，说明已经被其他标记线程访问过了，跳过不处理。

- 标记过程中Java 应用线程新创建的对象会直接进入 Marked0 视图。

- 标记过程中Java 应用线程访问对象时，如果对象的地址视图是 Remapped，就把对象地址视图切换到 Marked0，可以参考前面讲的读屏障。

标记结束后，如果对象地址视图是 Marked0，那就是活跃的，如果对象地址视图是 Remapped，那就是不活跃的。

### G1收集器和CMS的区别

- G1从整体上来看是 **标记-整理** 算法，但从局部（两个Region之间）是**复制**算法。而CMS是 **标记-清除算法** 所以说，G1不会产生内存碎片，而CMS会产生内存碎片
- CMS使用了 写后屏障来维护卡表，而G1不仅使用了写后屏障来维护卡表，还是用了 写前屏障来跟踪并发时的指针变化情况（为了实现原始快照）。
- CMS对Java堆内存使用的是传统的新生代和老年代划分方法，而G1使用的全新的划分方法。
- CMS收集器只收集老年代，可以配合新生代的Serial和ParNew收集器一起使用。G1收集器收集范围是老年代和新生代。不需要结合其他收集器使用
- CMS使用增量更新解决并发标记下出现的错误标记问题，而G1使用原始快照解决

## Minor GC,Major GC

> Minor GC (Young GC)

- **作用范围**：只针对年轻代进行回收，包括Eden区和两个Survivor区（S0和S1）。
- **触发条件**：当Eden区空间不足时，JVM会触发一次Minor GC，将Eden区和一个Survivor区中的存活对象移动到另一个Survivor区或老年代（Old Generation）。
- **特点**：通常发生得非常频繁，因为年轻代中对象的生命周期较短，回收效率高，暂停时间相对较短。

> Major GC

- **作用范围**：主要针对老年代进行回收，但不一定只回收老年代。
- **触发条件**：当老年代空间不足时，或者系统检测到年轻代对象晋升到老年代的速度过快，可能会触发Major GC。
- **特点**：相比Minor GC，Major GC发生的频率较低，但每次回收可能需要更长的时间，因为老年代中的对象存活率较高。

## 什么时候触发Full GC

- **空间分配担保机制**：在要进行 Young GC 的时候，发现`老年代可用的连续内存空间` < `新生代历次Young GC后升入老年代的对象总和的平均大小`，说明本次 Young GC 后可能升入老年代的对象大小，可能超过了老年代当前可用内存空间,那就会触发 Full GC。
- **Young GC 之后老年代空间不足**：执行 Young GC 之后有一批对象需要放入老年代，此时老年代就是没有足够的内存空间存放这些对象了，此时必须立即触发一次 Full GC
- **老年代空间不足**，老年代内存使用率过高，达到一定比例，也会触发 Full GC。
- **方法区内存空间不足**：如果方法区由永久代实现，永久代空间不足 Full GC。
- **System.gc()等命令触发**：System.gc()、jmap -dump 等命令会触发 full gc。

## 对象什么时候进入老年代?

![[Attachments/Pasted image 20240412220312.png]]

**长期存活的对象将进入老年代**

在对象的对象头信息中存储着对象的迭代年龄,迭代年龄会在每次 YoungGC 之后对象的移区操作中增加,每一次移区年龄加一.当这个年龄达到 15(默认)之后,这个对象将会被移入老年代。

**大对象直接进入老年代**

有一些占用大量连续内存空间的对象在被加载就会直接进入老年代.这样的大对象一般是一些数组,长字符串之类的对。

**动态对象年龄判定**

为了能更好地适应不同程序的内存状况，HotSpot 虚拟机并不是永远要求对象的年龄必须达到- XX：MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 空间中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。

**空间分配担保**

假如在 Young GC 之后，新生代仍然有大量对象存活，就需要老年代进行分配担保，把 Survivor 无法容纳的对象直接送入老年代。

## 强引用,软引用,弱引用,虚引用

引用类型主要分为强软弱虚四种：

- 强引用指的就是代码中普遍存在的赋值方式，比如A a = new A()这种。强引用关联的对象，**永远不会被GC回收。**
- 软引用可以用SoftReference来描述，指的是那些有用但是不是必须要的对象。系统**在发生内存溢出前**会对这类引用的对象进行回收。
- 弱引用可以用WeakReference来描述，他的强度比软引用更低一点，弱引用的对象**下一次GC的时候一定会被回收**，而不管内存是否足够。**弱引用可以很好的帮助我们实现本地缓存**
- 虚引用也被称作幻影引用，是最弱的引用关系，可以用PhantomReference来描述，他必须和ReferenceQueue一起使用，同样的当发生GC的时候，虚引用也会被回收。可以用虚引用来管理堆外内存。

## 内存泄漏和内存溢出的理解？

**内存泄露**：内存泄漏是指程序在运行过程中不再使用的对象仍然被引用，而无法被垃圾收集器回收，从而导致可用内存逐渐减少。虽然在Java中，垃圾回收机制会自动回收不再使用的对象，但如果有对象仍被不再使用的引用持有，垃圾收集器无法回收这些内存，最终可能导致程序的内存使用不断增加。

内存泄露常见原因：
- **静态集合**：使用静态数据结构（如`HashMap`或`ArrayList`）存储对象，且未清理。
- **ThreadLocal** 
- **资源未关闭**
- **单例模式**

内存溢出：内存溢出是指Java虚拟机（JVM）在申请内存时，无法找到足够的内存，最终引发`OutOfMemoryError`。这通常发生在堆内存不足以存放新创建的对象时。

内存溢出常见原因：
- **大量对象创建**：程序中不断创建大量对象，超出JVM堆的限制。
- **持久引用**：大型数据结构（如缓存、集合等）长时间持有对象引用，导致内存累积。
- **递归调用**：深度递归导致栈溢出。



## 对象逃逸分析

**对象一定分配在堆中吗？** 不一定的。

随着 JIT 编译期的发展与逃逸分析技术逐渐成熟，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。其实，在编译期间，JIT 会对代码做很多优化。其中有一部分优化的目的就是减少内存堆分配压力，其中一种重要的技术叫做逃逸分析。

**什么是逃逸分析？**

**逃逸分析**是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。

通俗点讲，当一个对象被 new 出来之后，它可能被外部所调用，如果是作为参数传递到外部了，就称之为方法逃逸。

**逃逸分析的好处**

- **栈上分配**

如果确定一个对象不会逃逸到线程之外，那么久可以考虑将这个对象在栈上分配，对象占用的内存随着栈帧出栈而销毁，这样一来，垃圾收集的压力就降低很多。

- **同步消除**

线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉。

- **标量替换**

如果一个数据是基本数据类型，不可拆分，它就被称之为标量。把一个 Java 对象拆散，将其用到的成员变量恢复为原始类型来访问，这个过程就称为标量替换。假如逃逸分析能够证明一个对象不会被方法外部访问，并且这个对象可以被拆散，那么可以不创建对象，直接用创建若干个成员变量代替，可以让对象的成员变量在栈上分配和读写。

## 类加载
### 类加载过程

![[Attachments/Pasted image 20240918145645.png]]

- **加载**：通过类的全限定名（包名 + 类名），获取到该类的.class文件的二进制字节流，将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构，在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口
- **连接**：验证、准备、解析 3 个阶段统称为连接。
    - **验证**：确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。验证阶段大致会完成以下四个阶段的检验动作：文件格式校验、元数据验证、字节码验证、符号引用验证
    - **准备**：为**类中的静态字段分配内存，并设置默认的初始值**，比如int类型初始值是0。被final修饰的static字段不会设置，因为final在编译的时候就分配了 . 侧重点在于分配所需要的内存空间，不会去执行更进一步的 JVM 指令
    - **解析**：解析阶段是虚拟机将常量池的 **「符号引用」直接替换为「直接引用」** 的过程。符号引用是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用的时候可以无歧义地定位到目标即可。直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，直接引用是和虚拟机实现的内存布局相关的。如果有了直接引用， 那引用的目标必定已经存在在内存中了。
- **初始化**：这一步真正去执行类初始化的代码逻辑，包括**静态字段赋值的动作，以及执行类定义中的静态初始化块内的逻辑**
- **使用**：使用类或者创建对象
- **卸载**：如果有下面的情况，类就会被卸载：1. 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例。2. 加载该类的ClassLoader已经被回收。 3. 类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

### 类加载器有哪些

简单来说，**类加载器的主要作用就是加载 Java 类的字节码（ `.class` 文件）到 JVM 中（在内存中生成一个代表该类的 `Class` 对象）**

每个 Java 类(class对象)都有一个引用指向加载它的 `ClassLoader`。不过，数组类不是通过 `ClassLoader` 创建的，而是 JVM 在需要的时候自动创建的，数组类通过`getClassLoader()`方法获取 `ClassLoader` 的时候和该数组的元素类型的 `ClassLoader` 是一致的。

- **`BootstrapClassLoader`(启动类加载器)**：最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ `%JAVA_HOME%/lib`目录下的 `rt.jar`、`resources.jar`、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
- **`ExtensionClassLoader`(扩展类加载器)**：主要负责加载 `%JRE_HOME%/lib/ext` 目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。
- **`AppClassLoader`(应用程序类加载器)**：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。

>**`rt.jar`**：rt 代表“RunTime”，`rt.jar`是 Java 基础类库，包含 Java doc 里面看到的所有的类的类文件。也就是说，我们常用内置库 `java.xxx.*`都在里面，比如`java.util.*`、`java.io.*`、`java.nio.*`、`java.lang.*`、`java.sql.*`、`java.math.*`。

还可以加入自定义的类加载器

除了 `BootstrapClassLoader` 是 JVM 自身的一部分之外，其他所有的类加载器都是在 JVM 外部实现的，并且全都继承自 `ClassLoader`抽象类。这样做的好处是用户可以自定义类加载器，以便让应用程序自己决定如何去获取所需的类。

每个 `ClassLoader` 可以通过`getParent()`获取其父 `ClassLoader`，如果获取到 `ClassLoader` 为`null`的话，那么该类是通过 `BootstrapClassLoader` 加载的

**为什么 获取到 `ClassLoader` 为`null`就是 `BootstrapClassLoader` 加载的呢？** 这是因为`BootstrapClassLoader` 由 C++ 实现，由于这个 C++ 实现的类加载器在 Java 中是没有与之对应的类的，所以拿到的结果是 null。

### 双亲委派模型

类加载器之间的父子关系一般不是以继承的关系来实现的，而是通常使用**组合**关系来复用父加载器的代码。

```java
public abstract class ClassLoader {
  ...
  // 组合
  private final ClassLoader parent;
  protected ClassLoader(ClassLoader parent) {
       this(checkCreateClassLoader(), parent);
  }
  ...
}
```

- 在类加载的时候，系统会首先判断当前类是否被加载过。**已经被加载的类会直接返回**，否则才会尝试加载（每个父类加载器都会走一遍这个流程）。内部有一个**vector存储了被加载过的类**
- 类加载器在进行类加载的时候，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成（调用父加载器 `loadClass()`方法来加载类）。这样的话，所有的请求最终都会传送到顶层的启动类加载器 `BootstrapClassLoader` 中。
- 只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载（调用自己的 `findClass()` 方法来加载类）。
- 如果子类加载器也无法加载这个类，那么它会抛出一个 `ClassNotFoundException` 异常。

### 双亲委派模型的作用

- **保证类的唯一性**：通过委托机制，确保了所有加载请求都会传递到启动类加载器，避免了不同类加载器重复加载相同类的情况，保证了Java核心类库的统一性，也防止了用户自定义类覆盖核心类库的可能。
- **保证安全性**：由于Java核心库被启动类加载器加载，而启动类加载器只加载信任的类路径中的类，这样可以防止不可信的类假冒核心类，增强了系统的安全性。例如，恶意代码无法自定义一个java.lang.System类并加载到JVM中，因为这个请求会被委托给启动类加载器，而启动类加载器只会加载标准的Java库中的类。
- **支持隔离和层次划分**：双亲委派模型支持不同层次的类加载器服务于不同的类加载需求，如应用程序类加载器加载用户代码，扩展类加载器加载扩展框架，启动类加载器加载核心库。这种层次化的划分有助于实现沙箱安全机制，保证了各个层级类加载器的职责清晰，也便于维护和扩展。
- **简化了加载流程**：通过委派，大部分类能够被正确的类加载器加载，减少了每个加载器需要处理的类的数量，简化了类的加载过程，提高了加载效率。

### 自定义类加载器

我们前面也说说了，除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`抽象类。

`ClassLoader` 类有两个关键的方法：

- `protected Class loadClass(String name, boolean resolve)`：加载指定二进制名称的类，实现了双亲委派机制 。`name` 为类的二进制名称，`resolve` 如果为 true，在加载时调用 `resolveClass(Class<?> c)` 方法解析该类。
- `protected Class findClass(String name)`：根据类的二进制名称来查找类，默认实现是空方法。

如果我们不想打破双亲委派模型，就重写 `ClassLoader` 类中的 `findClass()` 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载。但是，如果想打破双亲委派模型则需要重写 `loadClass()` 方法。

### 如何实现一个热部署功能

我们已经知道了 Java 类的加载过程。一个 Java 类文件到虚拟机里的对象，要经过如下过程:首先通过 Java 编译器，将 Java 文件编译成 class 字节码，类加载器读取 class 字节码，再将类转化为实例，对实例 newInstance 就可以生成对象。

类加载器 ClassLoader 功能，也就是将 class 字节码转换到类的实例。在 Java 应用中，所有的实例都是由类加载器，加载而来。

一般在系统中，类的加载都是由系统自带的类加载器完成，而且对于同一个全限定名的 java 类（如 com.csiar.soc.HelloWorld），只能被加载一次，而且无法被卸载。

这个时候问题就来了，如果我们希望将 java 类卸载，并且替换更新版本的 java 类，该怎么做呢？

既然在类加载器中，Java 类只能被加载一次，并且无法卸载。那么我们是不是可以直接把 Java 类加载器干掉呢？答案是可以的，我们可以自定义类加载器，并重写 ClassLoader 的 findClass 方法。

想要实现热部署可以分以下三个步骤：

- 1）销毁原来的自定义 ClassLoader
- 2）更新 class 类文件
- 3）创建新的 ClassLoader 去加载更新后的 class 类文件。

到此，一个热部署的功能就这样实现了。

### Tomcat的类加载机制了解吗

Tomcat 是主流的 Java Web 服务器之一，为了实现一些特殊的功能需求，自定义了一些类加载器。

Tomcat 类加载器如下：

![[Attachments/Pasted image 20240413004456.png]]

Tomcat 实际上也是破坏了双亲委派模型的。

Tomact 是 web 容器，可能需要部署多个应用程序。不同的应用程序可能会依赖同一个第三方类库的不同版本，但是不同版本的类库中某一个类的全路径名可能是一样的。如多个应用都要依赖 hollis.jar，但是 A 应用需要依赖 1.0.0 版本，但是 B 应用需要依赖 1.0.1 版本。这两个版本中都有一个类是 com.hollis.Test.class。如果采用默认的双亲委派类加载机制，那么无法加载多个相同的类。

所以，Tomcat 破坏了**双亲委派原则**，提供隔离的机制，为每个 web 容器单独提供一个 WebAppClassLoader 加载器。每一个 WebAppClassLoader 负责加载本身的目录下的 class 文件，加载不到时再交 CommonClassLoader 加载，这和双亲委派刚好相反。

## JVM参数配置

1. 显示指定堆内存

```sh
-Xms<heap size>[unit]
-Xmx<heap size>[unit]
```

2. 显示指定新生代内存

```sh
-XX:NewSize=<young size>[unit]
-XX:MaxNewSize=<young size>[unit]

# 一致
-Xmn256m
```

3. 设置老年代与新生代内存比值

```sh
-XX:NewRatio=1
```

4. 设置元空间出发full GC的阈值

```sh
-XX:MetaspaceSize=N #设置 Metaspace 的初始大小（是一个常见的误区，后面会解释）
-XX:MaxMetaspaceSize=N #设置 Metaspace 的最大大小
```

Metaspace 的初始容量并不是 `-XX:MetaspaceSize` 设置，无论 `-XX:MetaspaceSize` 配置什么值，对于 64 位 JVM 来说，Metaspace 的初始容量都是 21807104（约 20.8m）。

Metaspace 由于使用不断扩容到`-XX:MetaspaceSize`参数指定的量，就会发生 FGC，且之后每次 Metaspace 扩容都会发生 Full GC

5. 指定垃圾回收器

```sh
-XX:+UseSerialGC
-XX:+UseParallelGC
-XX:+UseParNewGC
-XX:+UseG1GC
```

6. GC日志记录

```sh
-XX:+PrintGCDetails
```

## 线上服务CPU占用过高怎么排查和分析原因

**排查 :** 

1. 执行“**top**”命令：查看所有进程占系统CPU的排序。极大可能排第一个的就是咱们的java进程（COMMAND列）。PID那一列就是进程号。
2. 执行“**top -Hp 进程号**”命令：查看java进程下的所有线程占CPU的情况。-H代表在进程中显示线程信息 , -p 进程号表示只显示这个进程信息![[Attachments/Pasted image 20240920154159.png]]
3. 执行“**printf "%x\\n 线程号**"命令 ：后续查看线程堆栈信息展示的都是十六进制，为了找到咱们的线程堆栈信息，咱们需要把线程号转成16进制。例如,printf "%x\\n 10"打印：a，那么在jstack中线程号就是0xa.
5. 执行 “**jstack 进程号 | grep 线程ID**”  查找某进程下-》线程ID（jstack堆栈信息中的nid）=0xa的线程状态。如果“"VM Thread" os_prio=0 tid=0x00007f871806e000 nid=0xa runnable”，第一个双引号圈起来的就是线程名，如果是“VM Thread”这就是虚拟机GC回收线程了
6. 执行“**jstat -gcutil 进程号 统计间隔毫秒 统计次数（缺省代表一致统计）**”，查看某进程GC持续变化情况，如果发现返回中FGC很大且一直增大-》确认Full GC! 也可以使用“jmap -heap 进程ID”查看一下进程的堆内从是不是要溢出了，特别是老年代内从使用情况一般是达到阈值(具体看垃圾回收器和启动时配置的阈值)就会进程Full GC。  
7. 执行“**jmap -dump:format=b,file=filename 进程ID**”，导出某进程下内存heap输出到文件中。然后使用jvisualVM

---

**原因分析 :**

1.**内存消耗过大**，导致Full GC次数过多

执行步骤1-5：

- 多个线程的CPU都超过了100%，通过jstack命令可以看到这些线程主要是垃圾回收线程-》上一节步骤4
- 通过jstat命令监控GC情况，可以看到Full GC次数非常多，并且次数在不断增加。--》上一节步骤5

确定是Full GC,接下来找到具体原因：

- 生成大量的对象，导致内存溢出-》执行步骤6，查看具体内存对象占用情况。
- 内存占用不高，但是Full GC次数还是比较多，此时可能是代码中手动调用 System.gc()导致GC次数过多，这可以通过添加 -XX:+DisableExplicitGC来禁用JVM对显示GC的响应。

2.代码中有**大量消耗CPU的操作**，导致CPU过高，系统运行缓慢；

执行步骤1-4：在步骤4jstack，可直接定位到代码行。例如某些复杂算法，甚至算法BUG，无限循环递归等等。

3.由于锁使用不当，导致**死锁**。

执行步骤1-4： 如果有死锁，会直接提示。关键字：deadlock.步骤四，会打印出业务死锁的位置。

造成死锁的原因：最典型的就是2个线程互相等待对方持有的锁。

4.随机出现**大量线程访问接口缓慢**。

代码某个位置有阻塞性的操作，导致该功能调用整体比较耗时，但出现是比较随机的；平时消耗的CPU不多，而且占用的内存也不高。

思路：

首先找到该接口，通过压测工具不断加大访问力度，大量线程将阻塞于该阻塞点。

![[Attachments/Pasted image 20240920140402.png]]



## 内存飙高怎么排查

分析： 内存飚高如果是发生在 java 进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。

1）先观察垃圾回收的情况

- jstat -gc PID 1000 查看 GC 次数，时间等信息，每隔一秒打印一次。
- jmap -histo PID | head -20 查看堆内存占用空间最大的前 20 个对象类型,可初步查看是哪个对象占用了内存。

如果每次 GC 次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。

2）导出堆内存文件快照

- jmap -dump:live,format=b,file=/home/myheapdump.hprof PID dump 堆内存信息到文件。

3）使用 visualVM 对 dump 文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题

## 频繁Full gc怎么办

Full GC 的排查思路大概如下：

1）清楚从程序角度，有哪些原因导致 FGC？

- **大对象**：系统一次性加载了过多数据到内存中（比如 SQL 查询未做分页），导致大对象进入了老年代。
- **内存泄漏**：频繁创建了大量对象，但是无法被回收（比如 IO 对象使用完后未调用 close 方法释放资源），先引发 FGC，最后导致 OOM.
- 程序频繁生成一些**长生命周期的对象**，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发 FGC. （即本文中的案例）
- **程序 BUG**
- 代码中**显式调用了 gc**方法，包括自己的代码甚至框架中的代码。
- JVM 参数设置问题：包括总内存大小、新生代和老年代的大小、Eden 区和 S 区的大小、元空间大小、垃圾回收算法等等。

2）清楚排查问题时能使用哪些工具

- 公司的监控系统：大部分公司都会有，可全方位监控 JVM 的各项指标。
- JDK 的自带工具，包括 jmap、jstat 等常用命令：

```java
# 查看堆内存各区域的使用率以及GC情况
jstat -gcutil -h20 pid 1000
# 查看堆内存中的存活对象，并按空间排序
jmap -histo pid | head -n20
# dump堆内存文件
jmap -dump:format=b,file=heap pid
```

- 可视化的堆内存分析工具：JVisualVM、MAT 等

3）排查指南

- 查看监控，以了解出现问题的时间点以及当前 FGC 的频率（可对比正常情况看频率是否正常）
- 了解该时间点之前有没有程序上线、基础组件升级等情况。
- 了解 JVM 的参数设置，包括：堆空间各个区域的大小设置，新生代和老年代分别采用了哪些垃圾收集器，然后分析 JVM 参数设置是否合理。
- 再对步骤 1 中列出的可能原因做排除法，其中元空间被打满、内存泄漏、代码显式调用 gc 方法比较容易排查。
- 针对大对象或者长生命周期对象导致的 FGC，可通过 jmap -histo 命令并结合 dump 堆内存文件作进一步分析，需要先定位到可疑对象。
- 通过可疑对象定位到具体代码再次分析，这时候要结合 GC 原理和 JVM 参数设置，弄清楚可疑对象是否满足了进入到老年代的条件才能下结论。

## 如何处理内存泄露

在 Java 中，和内存相关的问题主要有两种，内存溢出和内存泄漏。

- **内存溢出**（Out Of Memory）：就是申请内存时，JVM 没有足够的内存空间。通俗说法就是去蹲坑发现坑位满了。
- **内存泄露**（Memory Leak）：就是申请了内存，但是没有释放，导致内存空间浪费。通俗说法就是有人占着茅坑不拉屎。

内存泄漏是内在病源，外在病症表现可能有：

- CPU 使用率飙升，甚至到 100%
- 应用程序抛出 `OutOfMemoryError` 错误

严重的**内存泄漏**往往伴随频繁的 **Full GC**，所以排查内存泄漏问题时，需要从 Full GC 入手。主要有以下操作步骤：

第一步，使用 `jps` 查看运行的 Java 进程 ID

第二步，使用`top -p [pid]` 查看进程使用 CPU 和内存占用情况

第三步，使用 `top -Hp [pid]` 查看进程下的所有线程占用 CPU 和内存情况

第四步，将线程 ID 转换为 16 进制：`printf "%x\n" [pid]`，输出的值就是线程栈信息中的 **nid**。

> 例如：`printf "%x\n" 29471`，输出 **731f**。

第五步，抓取线程栈：`jstack 29452 > 29452.txt`，可以多抓几次做个对比。

在线程栈信息中找到对应线程号的 16 进制值，如下是 **731f** 线程的信息。线程栈分析可使用 VisualVM 插件 **TDA**。

```
"Service Thread" #7 daemon prio=9 os_prio=0 tid=0x00007fbe2c164000 nid=0x731f runnable [0x0000000000000000]
  java.lang.Thread.State: RUNNABLE
```

第六步，使用`jstat -gcutil [pid] 5000 10` 每隔 5 秒输出 GC 信息，输出 10 次，查看 **YGC** 和 **Full GC** 次数。

通常会出现 YGC 不增加或增加缓慢，而 Full GC 增加很快。

或使用 `jstat -gccause [pid] 5000` 输出 GC 摘要信息。

或使用 `jmap -heap [pid]` 查看堆的摘要信息，关注老年代内存使用是否达到阀值，若达到阀值就会执行 Full GC。

如果发现 `Full GC` 次数太多，就很大概率存在内存泄漏了

第八步，使用 `jmap -histo:live [pid]` 输出每个类的对象数量，内存大小(字节单位)及全限定类名。

第九步，生成 `dump` 文件，借助工具分析哪个对象非常多，基本就能定位到问题根源了。

使用 jmap 生成 dump 文件：

```
# jmap -dump:live,format=b,file=29471.dump 29471
Dumping heap to /root/dump ...
Heap dump file created
```

第十步，dump 文件分析

可以使用 **jhat** 命令分析：`jhat -port 8000 29471.dump`，浏览器访问 jhat 服务，端口是 8000。

也可以使用图形化工具分析，如 JDK 自带的 **jvisualvm**，从菜单 > 文件 > 装入 dump 文件。

或使用第三方式具分析的，如 **JProfiler**、**GCViewer** 工具。

或使用在线分析平台 **GCEasy**。

> **注意**：如果 dump 文件较大的话，分析会占比较大的内存。

在 dump 文析结果中查找存在大量的对象，再查对其的引用。基本上就可以定位到代码层的逻辑了。

## 解释执行和编译执行的区别

先说解释和编译的区别：

- 解释：将源代码逐行转换为机器码。
- 编译：将源代码一次性转换为机器码。

一个是逐行，一个是一次性，再来说说解释执行和编译执行的区别：

- 解释执行：程序运行时，将源代码逐行转换为机器码，然后执行。
- 编译执行：程序运行前，将源代码一次性转换为机器码，然后执行。

Java 一般被称为“解释型语言”，因为 Java 代码在执行前，需要先将源代码编译成字节码，然后在运行时，再由 JVM 的解释器“逐行”将字节码转换为机器码，然后执行。

这也是 Java 被诟病“慢”的主要原因。

但 JIT 的出现打破了这种刻板印象，JVM 会将热点代码（即运行频率高的代码）编译后放入 CodeCache，当下次执行再遇到这段代码时，会从 CodeCache 中直接读取机器码，然后执行。这大大提升了 Java 的执行效率。

## Class文件结构

根据 Java 虚拟机规范，Class 文件通过 `ClassFile` 定义，有点类似 C 语言的结构体。

`ClassFile` 的结构如下：

```java
ClassFile {
    u4             magic; //Class 文件的标志
    u2             minor_version;//Class 的小版本号
    u2             major_version;//Class 的大版本号
    u2             constant_pool_count;//常量池的数量
    cp_info        constant_pool[constant_pool_count-1];//常量池
    u2             access_flags;//Class 的访问标记
    u2             this_class;//当前类
    u2             super_class;//父类
    u2             interfaces_count;//接口数量
    u2             interfaces[interfaces_count];//一个类可以实现多个接口
    u2             fields_count;//字段数量
    field_info     fields[fields_count];//一个类可以有多个字段
    u2             methods_count;//方法数量
    method_info    methods[methods_count];//一个类可以有个多个方法
    u2             attributes_count;//此类的属性表中的属性数
    attribute_info attributes[attributes_count];//属性表集合
}
```


